	.TITLE FIS-EMULATOR
;	EMULATOR FOR FOLLOWING PDP INSTRUCTIONS:
;
;	FADD,FSUB,FMUL,FDIV
;
;       PIECES TAKEN FROM EI.SYS BY DR P.C.WAGGETT,
;
;	WRITTEN 25-NOV-85 BY:
;		PAUL LUSTGRAAF
;		32 CARVER HALL
;		IOWA STATE UNIVERSITY
;		AMES, IA 50011
;		515-294-1832
;
;	LAST REVISION: 22-APR-86
;
; METHOD OF OPERATION:
;   LOAD FI:
;   SET FI ON
;   UNLOAD FI:
;   LOAD FI:
;       STEALS VECTOR 10 (ILLEGAL INSTRUCTION TRAP) FROM THE MONITOR.
;       WHEN AN EMULATED INSTRUCTION IS ATTEMPTED, THIS PSEUDO-HANDLER GETS
;	CONTROL.  IF THE INSTRUCTION CAUSING THE TRAP IS NOT ONE OF THE
;	EMULATED INSTRUCTIONS OR IS ILLEGAL FOR SOME OTHER REASON, THIS
;	ROUTINE PASSES IT ALONG TO THE PREVIOUS TRAP ROUTINE.  THUS, IT IS
;	POSSIBLE TO HAVE MORE THAN ONE HANDLER CONNECTED TO VECTOR 10.
;	THE UNLOAD AND LOAD SEQUENCE MUST BE DONE IN RT-11 BECAUSE RT-11
;	DOES NOT MODIFY THE HANDLER IMAGE IN MEMORY LIKE TSX+ DOES.
;   SET FI OFF
;	RESTORES VECTOR 10 TO THE ORIGINAL CONTENTS.  THIS
;	*MUST* BE DONE BEFORE UNLOADING THIS HANDLER OR YOU MAY
;	CRASH THE SYSTEM.

;  KNOWN ERRORS:
;     THE ADDITION ROUTINE SOMETIMES DIFFERS IN THE LEAST SIGNIFICANT
;     BIT FROM THE RESULTS GIVEN BY THE FIS HARDWARE.  IT APPEARS TO
;     BE A ROUNDING ERROR OF SOME SORT.
; INITIALIZATION CODE

	.MCALL .DRDEF,.DSTATUS
	FICODE=374
	.DRDEF	FI,FICODE,0,0,0,0	;THIS IS A PSEUDO-HANDLER
	TRAPPC=10
	TRAPPS=12
	.DRSET	ON,1,ONTRN		;OPTION FOR TURN-ON
	.DRSET	OFF,1,OFFRTN		;OPTION FOR TURN-OFF

ONTRN:	MOV	PC,R2		;R2=ACTUAL ADDRESS
	ADD	#DBLK0-.,R2	;R2=ACTUAL ADDRESS OF DBLK0
	MOV	PC,R1		;R1=ACTUAL ADDRESS
	ADD	#ENAM-.,R1	;R1=ACTUAL ADDRESS OF ENAM
	.DSTATUS R2,R1		;GET STATUS OF THIS HANDLER
	BCS	BAD		;IF NOT INSTALLED, BRANCH
	CMPB	DBLK0,#FICODE	;RIGHT DRIVER ?
	BNE	BAD		;NO !
	TST	DBLK0+4		;TEST TO SEE IF LOADED
	BEQ	BAD		;NO.EXIT
	ADD	#4,DBLK0+4	;OUR STARTING ADDRESS 4 BYTES LATER
	CMP	@#TRAPPC,DBLK0+4	;SET FI ON ALREADY DONE?
	BEQ	GOOD			;IF SO, BRANCH
	MOV	@#TRAPPC,SAVEPC		;SAVE OLD CONTENTS OF LOCATION 10
	MOV	@#TRAPPS,SAVEPS		;SAVE OLD CONTENTS OF LOC 12
	MOV	DBLK0+4,@#TRAPPC	;STORE OUR ROUTINE ADDRESS IN LOC 10
.IF EQ, MMG$T
	CLR	@#TRAPPS		;RUN AT PRIORITY 0
.ENDC
GOOD:	CLC
	RETURN
BAD:	SEC			;ERROR EXIT..CARRY SET !
	RETURN
OFFRTN:	MOV	SAVEPS,@#TRAPPS	;RESTORE LOC 12
	MOV	SAVEPC,@#TRAPPC	;RESTORE LOCATION 10
	BR	GOOD
DBLK0:	.BLKW 4			;DSTATUS DATA BLOCK
ENAM:	.RAD50	/FI/		;NAME OF DRIVER IN RAD50
;  DRIVER CODE FOR DEALING WITH INSTRUCTIONS

	.DRBEG	FI		;DRIVER CODE  OLD PSW,PC ON STACK
.IF EQ,MMG$T
	TST	-(SP)		;SPACE FOR OLD SP
	MOV	SP,(SP)		;STORE SP
	ADD	#6,(SP)		;ADJUST TO GET USER SP
.IFF
	.MFPI	SP		;GET SP FROM USER SPACE
.ENDC
	CLR	-(SP)		;EFFECTIVE ADDRESS
	CLR	-(SP)		;RESERVE SPACE FOR TRAPPED$INSTRUCTION
	MOV	10(SP),-(SP)	;PSW TO RETURN
	MOV	10(SP),-(SP)	;PC TO RETURN ON STACK
	MOV	10(SP),-(SP)	;SP TO RETURN
	MOV	R5,-(SP)	;SAVE OLD REGISTER VALUES
	MOV	R4,-(SP)
	MOV	R3,-(SP)
	MOV	R2,-(SP)
	MOV	R1,-(SP)
	MOV	R0,-(SP)
	OLDPSW=26.		;OFFSET OF USER PSW
	OLDPC=24.		;OFFSET OF USER PC
	OLDSP=22.		;OFFSET OF USER SP
	EA=20.			;OFFSET OF EFFECTIVE ADDRESS
	WHAT=18.		;OFFSET OF TRAPPED INSTRUCTION
	NEWPSW=16.		;OFFSET OF PSW TO RETURN
	NEWPC=14.		;OFFSET OF USER PC TO RETURN
	MOV	NEWPC(SP),R1	;PUT NEWPC INTO R1
	SUB	#2,R1		;R1->TRAPPED INSTRUCTION
	CALL	GETWRD		;GET TRAPPED INSTRUCTION
	MOV	R0,WHAT(SP)	;STORE TRAPPED INSTRUCTION ON STACK
;DECODE THE INSTRUCTION
	BIC	#37,R0		;MASK OFF ALL BUT THE GENERIC FIS OP CODE
	CMP	R0,#75000	;IS THIS AN FIS INSTRUCTION?
	BEQ	GETOP		;IF SO, BRANCH TO PROCESSING ROUTINE
	MOV	(SP)+,R0	;RESTORE R0
	MOV	(SP)+,R1	;RESTORE R1
	ADD	#EA,SP		;RESTORE STACK.POINTER
	MOV	(PC)+,-(SP)	;STACK OLD PSW FOR LOC 12
SAVEPS:	.WORD	0		;OLD PSW FROM LOC 12
	MOV	(PC)+,-(SP)	;STACK OLD PC FOR LOC 10
SAVEPC:	.WORD	0		;OLD PC FROM LOC 10
	RTI			;JUMP TO THE PREVIOUS TRAP HANDLER
;WE HAVE A VALID INSTRUCTION, NOW GET THE VALUES TO OPERATE ON.

GETOP:	MOV	WHAT(SP),R0	;GET TRAPPED-INSTRUCTION
	BIC	#177770,R0	;GET REGISTER
	ASL	R0		;R0=OFFSET
	ADD	SP,R0		;R0=ADDRESS OF REGISTER TO USE
	MOV	R0,EA(SP)	;STORE REGISTER ADDRESS FOR RESULT
	MOV	(R0),R1		;R1=EFFECTIVE ADDRESS(EA) OF FIRST VALUE
	CALL	GETWRD		;GET THE FIRST WORD OF VALUE 1
	MOV	R0,R2		;R2=HIGH ORDER VALUE1
	ADD	#2,R1		;POINT TO NEXT WORD
	CALL	GETWRD		;GET THE NEXT WORD
	MOV	R0,R3		;R3=LOW ORDER VALUE1
	ADD	#2,R1		;POINT TO NEXT WORD
	CALL	GETWRD		;GET THE NEXT WORD
	MOV	R0,R4		;R4=HIGH ORDER VALUE2
	ADD	#2,R1		;POINT TO NEXT WORD
	CALL	GETWRD		;GET THE NEXT WORD
	MOV	R0,R5		;R5=LOW ORDER VALUE2
; NOW JUMP TO THE PROCESSING ROUTINE.
	BIC	#17,NEWPSW(SP)	;CLEAR CONDITION CODES
	MOV	WHAT(SP),R0	;GET TRAPPED INSTRUCTION
	BIC	#177747,R0	;MASK OFF ALL BUT THE OP CODE
	ASR	R0		;DIV OP CODE BY 2 TO GET OFFSET
	ADD	R0,PC		;EXECUTE A JUMP INSTRUCTION TO TABLE
;TABLE OF INSTRUCTIONS
	JMP	FADDDO
	JMP	FSUBDO
	JMP	FMULDO
	JMP	FDIVDO
;END OF TABLE OF EXECUTED INSTRUCTIONS

;GET A WORD FROM THE USER'S SPACE IN EITHER MAPPED OR NON-MAPPED SYSTEMS.

GETWRD:	
.IF EQ,MMG$T
	MOV	(R1),R0		;GET THE WORD DIRECTLY
.IFF
	MFPI	(R1)		;PUSH THE WORD ON THE STACK
	MOV	(SP)+,R0	;POP TO R0
.ENDC
	RETURN

;STORE A WORD INTO THE USER'S SPACE IN EITHER MAPPED OR NON-MAPPED SYSTEMS.

PUTWRD:
.IF EQ,MMG$T
	MOV	R0,(R1)		;STORE THE WORD DIRECTLY
.IFF
	MOV	R0,-(SP)	;PUSH RESULT ON STACK FOR MTPI
	MTPI	(R1)		;MOVE TO USER SPACE
.ENDC
	RETURN
;ROUTINE TO CHANGE DESTINATION, THEN EXIT.

MOVEOU:	MOV	EA(SP),R0	;GET REGISTER ADDRESS
	ADD	#4,(R0)		;INCREMENT REGISTER CONTENTS
	MOV	(R0),R1		;GET EA OF RESULT
	MOV	R2,R0		;GET FIRST WORD OF RESULT
	CALL	PUTWRD		;STORE IT
	ADD	#2,R1		;POINT TO NEXT WORD
	MOV	R3,R0		;GET SECOND WORD OF RESULT
	CALL	PUTWRD		;STORE IT

; RETURN TO USER

DOEXIT:	MOV	(SP)+,R0	;RESTORE REGISTERS 0-5
	MOV	(SP)+,R1
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	MOV	(SP)+,R4
	MOV	(SP)+,R5
	CMP	(SP),OLDSP-12.(SP)	;CHANGE SP?
	BEQ	DORET			;IF NOT, BRANCH
.IF EQ,MMG$T
	TST	(SP)+			;DELETE NEW SP
	MOV	(SP)+,OLDPC-12.(SP)	;UPDATE USER PC
	MOV	(SP)+,OLDPSW-14.(SP)	;UPDATE USER PSW
	ADD	#10.,SP			;POINT STACK TO PC,PSW
	BR	FIDONE
.IFF
	MOV	(SP),-(SP)		;STACK USER SP FOR MTPI
	MTPI	SP			;CHANGE USER SP
.ENDC
DORET:	TST	(SP)+			;DELETE NEW SP
	MOV	(SP)+,OLDPC-16.(SP)	;UPDATE USER PC
	MOV	(SP)+,OLDPSW-18.(SP)	;UPDATE USER PSW
	ADD	#6,SP			;POINT STACK TO PC,PSW
FIDONE:	RTI
; ROUTINE TO PERFORM AN FSUB INSTRUCTION (07501R).

FSUBDO:	TST	R2		;IS VALUE1=0?
	BEQ	FADDDO		;IF SO, BRANCH
	ADD	#100000,R2	;SUBTRACT IS SAME AS ADDING THE NEGATIVE

; ROUTINE TO PERFORM AN FADD INSTRUCTION (07500R).

FADDDO:	TST	R2		;IS VALUE1 0?
	BEQ	91$		;IF SO, BRANCH
	TST	R4		;IS VALUE2 0?
	BEQ	90$		;IF SO, BRANCH
	ASL	R3		;SHIFT VALUE1 LEFT
	ROL	R2		;SHIFT SIGN1 TO CARRY BIT
	ROL	-(SP)		;(SP)=SIGN OF VALUE1
	MOV	R2,R0
	SWAB	R0		;GET EXP1 IN LOWER BYTE
	BIC	#177400,R0	;R0=EXP1
	BIC	#177400,R2	;R2=HIGH ORDER FRACTION1
	BIS	#400,R2		;SET HIDDEN BIT
	ASL	R3		;USE AN EXTRA GUARD BIT
	ROL	R2
	ROR	(SP)		;NEGATIVE?
	BCC	1$		;IF NOT, BRANCH
	NEG	R3		;NEGATE FRACTION1
	ADC	R2
	NEG	R2
1$:	ASL	R5		;SHIFT VALUE2 LEFT
	ROL	R4		;SHIFT SIGN2 TO CARRY BIT
	ROL	(SP)		;(SP)=SIGN2
	MOV	R4,R1
	SWAB	R1		;GET EXP2 IN LOWER BYTE
	BIC	#177400,R1	;R1=EXP2
	BIC	#177400,R4	;R4=HIGH ORDER FRACTION2
	BIS	#400,R4		;SET HIDDEN BIT
	ASL	R5		;USE AN EXTRA GUARD BIT
	ROL	R4
	ROR	(SP)+		;NEGATIVE?
	BCC	2$		;IF NOT, BRANCH
	NEG	R5		;NEGATE FRACTION2
	ADC	R4
	NEG	R4
2$:	SUB	R0,R1		;R1=E2-E1, R0=E1
	BEQ	40$		;IF NO SHIFTING NEEDED (R1=0), BRANCH
	BLT	5$		;IF E2<E1, BRANCH
	ADD	R1,R0		;R1=E2-E1, R0=E2, E2>E1
	MOV	R4,-(SP)	;SWAP VALUE1 AND VALUE2
	MOV	R2,R4
	MOV	(SP)+,R2
	MOV	R5,-(SP)	
	MOV	R3,R5
	MOV	(SP)+,R3
	NEG	R1		;R1=AMOUNT TO SHIFT VALUE2 RIGHT
5$:	CMP	R1,#-26.	;ANY POINT IN SHIFTING?
	BGE	7$		;IF SO, BRANCH
	CLR	R1		;R1=0 AT END
	CLR	R4		;WE SHIFTED IT RIGHT OUT OF THERE
	CLR	R5
	BR	40$
7$:	ASR	R4		;SHIFT RIGHT R1 TIMES
	ROR	R5
	INC	R1		;COUNT LOOP
	BLT	7$
;NOW ADD THE VALUES
40$:	ADD	R5,R3		;ADD THE FRACTIONS
	ADC	R2		;DOUBLE PRECISION ADD
	ADD	R4,R2
	BPL	50$		;IF RESULT POSITIVE, BRANCH
	NEG	R3		;ELSE GET ABSOLUTE VALUE
	ADC	R2
	NEG	R2
	INC	R1		;AND REMEMBER NEGATIVE
;NOW NORMALIZE THE RESULT IN R2,R3
50$:	BIT	#176000,R2	;NEED TO SHIFT RIGHT?
	BEQ	60$		;IF NOT, BRANCH
	ASR	R2		;SHIFT RIGHT
	ROR	R3
	INC	R0		;ADJUST EXPONENT
	BR	50$
60$:	TST	R2		;IS THE RESULT 0?
	BNE	61$		;IF NOT, BRANCH
	TST	R3		;TEST THE LOW ORDER WORD
	BEQ	RETZER		;IF RESULT 0, BRANCH
61$:	BIT	#177000,R2	;NEED TO SHIFT LEFT?
	BNE	70$		;IF NOT, BRANCH
	ASL	R3		;SHIFT LEFT
	ROL	R2
	DEC	R0		;ADJUST EXPONENT
	BR	61$
;NOW PUT THE RESULT BACK TOGETHER
70$:	ASR	R2		;DELETE EXTRA GUARD BIT
	ROR	R3
	TST	R0		;TEST THE EXPONENT FOR UNDERFLOW
	JMP	CHKEXP		;JOIN COMMON CODE
91$:	MOV	R4,R2		;RESULT EXPECTED IN R2,R3
	MOV	R5,R3
90$:	TST	R2		;TEST RESULT
	JMP	SETCC
;  ROUTINE TO PERFORM AN FMUL INSTRUCTION (07502R).

FMULDO:	MOV	R2,R0		;R0=HIGH ORDER VALUE1
	BEQ	RETZER		;IF 0, RETURN 0
	MOV	R3,R1		;R1=LOW ORDER VALUE1
	ASL	R4		;SHIFT HIGH MULTIPLIER
	BEQ	RETZER		;IF 0, RETURN 0
	ROL	-(SP)		;KEEP SIGN
	SEC			;C=HIDDEN BIT
	RORB	R4		;INSERT HIDDEN BIT
	ASL	R1		;SHIFT MULTIPLICAND (VALUE1)
	ROL	R0		;CONTINUE TO HIGH ORDER
	ADC	(SP)		;GET PRODUCT SIGN
	SWAB	R0		;REVERSE BYTES OF HIGH ORDER VALUE1
	CLR	-(SP)		;GET SPACE FOR EXPONENT
	MOVB	R0,(SP)		;KEEP MULTIPLICAND EXPONENT
	CLRB	R0		;DELETE EXPONENT
	SWAB	R0		;RESTORE BYTE ORDER
	BIS	#400,R0		;INSERT NORMAL BIT INTO FRACTION
	CLR	R2		;CLEAR PRODUCT
	CLR	R3
	MOV	R4,-(SP)	;SAVE HIGH ORDER VALUE2
	MOV	R5,R4		;GET LOW ORDER MULTIPLIER
	BEQ	2$
	MOV	#16.,R5		;DO FIRST 16 BITS
	CALL	IMUL		;MULTIPLY R0,R1 BY R4 GIVING R2,R3
2$:	MOV	(SP)+,R4	;GET HIGH ORDER VALUE1
	MOV	#8.,R5		;THERE ARE ONLY EIGHT OF THEM
	CALL	IMUL		;MULTIPLY R0,R1 BY R4 GIVING R2,R3
	ROL	R0		;SAVE LAST BIT ROTATED OUT
	ADD	(SP)+,R4	;ADD EXPONENTS
	BIT	#177400,R2	;IS HIDDEN BIT IN PROPER PLACE?
	BNE	3$		;IF SO, BRANCH
	ROR	R0		;RETRIEVE LAST BIT
	ROL	R3		;PUT IT BACK IN PLACE
	ROL	R2		;MUST HAVE GOT IT NOW
	DEC	R4		;ADJUST EXPONENT
3$:	MOV	(SP)+,R1	;GET THE PRODUCT SIGN
	SUB	#200,R4		;TAKE OUT ONE OF THE EXCESS 128S
	MOV	R4,R0
	JMP	CHKEXP		;JOIN COMMON CODE

; INTEGER MULTIPLY SUBROUTINE
; MULTIPLY R0,R1 BY R4 GIVING R2,R3

IMUL:	CLC			;CLEAR C BIT
	ROR	R4		;TEST NEXT MULTIPLIER BIT
	BCC	2$		;JUMP IF IT IS 0
	ADD	R1,R3
	ADC	R2
	ADD	R0,R2
2$:	ROR	R2		;NOW SHIFT PRODUCT
	ROR	R3
	DEC	R5		;COUNT LOOP
	BGT	IMUL		;AGAIN PLEASE
	RTS	PC		;RETURN TO CALLER
;ROUTINES TO HANDLE ERRORS

DIVZER:	BIS	#1,NEWPSW(SP)	;SET C BIT FOR DIVIDE BY 0
UNDER:	BIS	#10,NEWPSW(SP)	;SET N FOR UNDERFLOW
OVER:	BIS	#2,NEWPSW(SP)	;SET V FOR OVERFLOW

; SIMULATE A HARDWARE TRAP ON ERRORS

TRAPIT:	MOV	(SP)+,R0	;RESTORE REGISTERS 0-5
	MOV	(SP)+,R1
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	MOV	(SP)+,R4
	MOV	(SP)+,R5
	TST	(SP)+			;DELETE NEW SP
	MOV	(SP)+,OLDPC-16.(SP)	;UPDATE USER PC
	MOV	(SP)+,OLDPSW-18.(SP)	;UPDATE USER PSW
	ADD	#6,SP			;POINT STACK TO PC,PSW
	MOV	@#246,-(SP)		;SIMULATES AN ERROR TRAP
	MOV	@#244,-(SP)		;OUT OF THE FPU HARDWARE
	RTI

; ROUTINE TO HANDLE NORMAL RETURN

	.ENABL	LSB
CHKEXP:	BLE	UNDER		;IF R0<=0, BRANCH
	SWAB	R0		;PUT EXPONENT IN HIGH BYTE
	BNE	OVER		;IF LOW ORDER BYTE <> 0, THEN OVERFLOW
	BISB	R2,R0		;INSERT HIGH-ORDER 8 BITS IN LOW BYTE,
				;DROPPING HIDDEN BIT
	MOV	R0,R2		;R2=EXP,MANTISSA
	ROR	R1		;GET THE SIGN BIT IN C
	ROR	R2		;INSERT THE SIGN BIT
	ROR	R3		;SHIFT TO LOW ORDER
	ADC	R3		;ROUND THE RESULT
	ADC	R2		
	BVS	OVER		;IF OVERFLOW, BRANCH
	BCS	OVER		;DITTO
SETCC:	BEQ	98$		;IF R2 ZERO, BRANCH
	BPL	99$		;IF R2 POSITIVE, BRANCH
	BIS	#10,NEWPSW(SP)	;SET N BIT
	BR	99$
RETZER:	CLR	R2		;MAKE RESULT 0
	CLR	R3
98$:	BIS	#4,NEWPSW(SP)	;SET Z BIT
99$:	JMP	MOVEOU
	.DSABL	LSB
; ROUTINE TO PERFORM AN FDIV INSTRUCTION (07503R).

FDIVDO:	MOV	R2,R0		;R0=HIGH ORDER DENOMINATOR (VALUE1)
	BEQ	DIVZER		;IF 0, ERROR
	MOV	R3,R1		;R1=LOW ORDER VALUE1
	ASL	R5		;SHIFT LOW ORDER NUMERATOR (VALUE2)
	ROL	R4		;SHIFT HIGH ORDER NUMERATOR
	BEQ	RETZER		;IF 0, RETURN 0
	ROL	-(SP)		;KEEP SIGN
	SWAB	R4		;REVERSE BYTES OF HIGH ORDER VALUE2
	CLR	-(SP)		;GET SPACE FOR EXPONENT
	MOVB	R4,(SP)		;KEEP EXP2
	CLRB	R4		;DELETE EXPONENT
	SWAB	R4		;RESTORE BYTE ORDER
	BIS	#400,R4		;INSERT NORMAL BIT INTO FRACTION
	ASL	R1		;SHIFT VALUE1
	ROL	R0		;CONTINUE TO HIGH ORDER
	ADC	2(SP)		;GET PRODUCT SIGN
	SWAB	R0		;REVERSE BYTES OF HIGH ORDER VALUE1
	CLR	-(SP)		;GET SPACE FOR EXP1
	MOVB	R0,(SP)		;STORE EXP1
	SUB	(SP)+,(SP)	;SUBTRACT EXPONENTS GIVING EXP OF RESULT
	CLRB	R0		;DELETE EXPONENT
	SWAB	R0		;RESTORE BYTE ORDER
	BIS	#400,R0		;INSERT NORMAL BIT INTO FRACTION
	CLR	R2		;R2=HIGH ORDER QUOTIENT
	CLR	R3		;R3=LOW ORDER QUOTIENT
	CMP	R4,R0		;COMPARE HIGH NUM AND DEN
	BLO	2$		;JUMP IF DENOMINATOR HIGH
	BHI	1$		;JUMP IF DENOMINATOR LOW
	CMP	R5,R1		;COMPARE LOW ORDER PARTS
	BHI	1$
	BNE	2$
	INC	(SP)		;QUOTIENT FRACTION=1, BUMP EXPONENT
	BR	4$
1$:	ROR	R4		;HALVE NUMERATOR (C=0)
	ROR	R5		;TO ENSURE THAT N<D
	INC	(SP)		;COMPENSATE EXPONENT
2$:	MOV	#9.,R2		;GO DO FIRST 9 QUOTIENT BITS
	CALL	IDIV
	MOV	R3,-(SP)	;SAVE HIGH ORDER QUOTIENT
	MOV	#16.,R2		;GO DO 16 MORE BITS
	CALL	IDIV
3$:	MOV	(SP)+,R2	;RECOVER HIGH ORDER QUOTIENT
4$:	MOV	(SP)+,R0	;RECOVER EXPONENT
	MOV	(SP)+,R1	;R1=SIGN OF QUOTIENT
	ADD	#200,R0		;ADD IN EXCESS 128
	JMP	CHKEXP		;JOIN COMMON CODE
; LONG INTEGER DIVIDE ROUTINE
; DIVIDE R4,R5 BY R0,R1 GIVING R3

IDIV:	ASL	R3		;SHIFT QUOTIENT
	ASL	R5		;SHIFT NUMERATOR
	ROL	R4
	BCS	1$		;GUARANTEED TO GO
	CMP	R0,R4		;COMPARE HIGH DIVISOR AND DIVIDEND
	BHI	2$		;JUMP IF DIVISOR BIGGER
	BLO	1$		;JUMP IF DIVISOR SMALLER
	CMP	R1,R5		;CHECK THE LOW ORDERS
	BHI	2$
1$:	SUB	R1,R5		;N=N-D
	SBC	R4
	SUB	R0,R4
	INC	R3		;INSERT QUOTIENT BIT
2$:	DEC	R2		;COUNT LOOP
	BGT	IDIV
	RTS	PC

; END OF HANDLER

	.DRAST	FI,4
	.DRFIN	FI		;DUMMY INTERRUPT ROUTINE AS NEVER INTERRUPTED
	.DREND	FI		;DRIVER END
	.END
