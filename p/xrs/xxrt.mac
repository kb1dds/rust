;	XXDP app memory limit does not accommodate DRS space
;	Pogrammable clock re-enable
;	Save image space by overlaying memory image with driver code?
;	Add get/set system variables across DCL calls
;	^Z -> <?Batch fail: ->
;	Batch image ctrl-c, ctrl-z don't echo
;	c xxxx|^Z - HALT
;	BOO/FOR DD: works, DUP BOOT fails
;	SET NOSHELL, NOEXPAT
;	XTECO - accepts '}' and '~' as ESC; can't run from Batch
;	EXPAT RUST DIR RTS:\RTB\ fails
;	XXRT device:, host SY:, host DK:
;	Check XX, EXPAT and XXHELP present with /V
;	X SHOW - XX: is [not] loaded
;	V2 directory version numbers
;	X25:ZFPCA0.BIC I/O PAGE ADDRESS FINDER 
;	Find non-standard use of 104035
;	EXPAT DIR - No files found: pdp:\rust^rl2\
;	UPD2 DIR fails for HD:
;	UPDAT fails
;	DIFFER blank lines, spaces, comments
;	HELP
;
;	IF x [THEN], Chain file[/]condition/condition
;
;	HELP/DOCUMENT is broken
;	BOOT is broken
;	UCL is broken
;	IMGINF is broken
;	ANALYSE - count EMT's below 104061
;
;	FLOAT.BIN - Floating addresses
;	SIZER6.BIC - Memory map
;	ROLLIN.BIC - Tape archiver
;
;	x23:xmonc0.pat 14xxxx
;	x23:jkdjb0.bin 133xxx
;	x25:epomur.bin
;	rt$rst comments
;
;	X11 understood, .OBJ listed
;	EXPAT DIR/XXDP produces listings (.BI?, .SYS, .OBJ); contiguous
;	default start - restart
;	batch start
;	CLI FKAA, repeats, no ctrl-c
;	XM restart after FKAA?? crashes
;
;	<s> remembers last start address
;	<r xxcpu><odt> invalid command
;	ODT
;	VT100 paging works under SimH
;	EXPAT doesn't show files lacking file types; neither does US
;	EXPAT/dates not working
;	separate V1/V2 XMS
;	how much space does XXDPSM take?
;	how many diagnostics use XXDPXM facilities?
;	how many XXDPXM EMTs, TRAPS
;	do all XX diagnostics use DRS?
;	b$alin is impure
;	XRS:UPDATE.COM
;	Cleanup EXERT low memory on exit
;	SimH Magtape gkmem
;	Hoppe has no CT driver and no magtape images
;	I can use DR.ENT/DR.UFD for RT11A next/last block!
;	SimH testing
;	Fix calc for XXRT
;
;	Update DUMP/SRCDIF to do code compares
;	srcdif fails for lots of differnces
;	Get unibus test from BSTRAP
;	sks:gkmem.r
;	RT-11 V57 EDIT/CREATE fails "No dev"; V56 is fine.
;	<rt cmd> has non-DCL problems with ^C
;
;	XM batch is probing the keyboard
;	finish /wait
;	check all batch errors and messages
;	DU1: has to be a problem
;	Note: DU1, read-only, LD:
;	Maintainence test for corrupted monitor
;	<#xx xx xx> leaves a ^C trail which wipe out subsequent DCL apps
;	bu$ret = clr @#42
;	pshb/popb
;	unclear why ctrl-s has to store a keycode
;	Add invalid EMT check
;	cc$swr error branch
;	cu$sta ParDec error message is wrong
;	Need BUS abort mechanism.
;	XXDP23 is actually XXDP22
;	SMI/CMI applies to DRS diagnostics. Update HELP.
;	Why Batch BIC vs CLI MOV @#52?
;	What are the flags in @#52?
;	SET XX [NO]VT100
;	Complete CUS:FUN.R and add to CCS:DECUSC.TXT.
;	Further compress DECUSC.
;	Detect SYSMAC
;	\xxdp23\ZQU1C0.BIN (UPD2) fails; x23: okay
;	LoaSup activation path for CLI/Batch
;	Add DRS app stuff to EXPAT ANALYSE
;	Image activation protocol documentation
;	Need better filespec algorithm
;	Compute DRVFRE
;	.BIX for apps that don't obey start address
;	ctrl-z still needs solving
;
;	V11 wrong ascii output - tmp:xxdiag.r/.bin
;	EXPAT tape, dos, dectape, .TAP, .DTA
;	RLS:OSDET.R
;	EXPAT XXRT
;	@#42 batch cli
;	Add XXDP system detection to V11
;	RT$OPN newline
;	bu$ret exit paths
;	Add error messages for CLI numeric input
;	EXPAT IDENTIFY command
;	Rebuild BU$ACT/BU$RET
;	XXRT supports UCL
;	Batch start
;	Batch ctrl-z should be generic
;	Write DSR test app
;	Document CLI <r app/n> and remove <r app/qv>. Help as well.
;	Document batch <if ^C then>
;	Document batch ctrl-c and ctrl-z
;	ACT11 seen
;	XXCPU obliterates low memory
;	D
;	G(et) copies from XXDP media
;	RESET and MSCP
;	trap catchers
;	d$pdev
;	HELP uses the prompt without a space
;	XXDIAG fails when running from HD5:
;	Add section describing bug fixes
;	Driver guide says that DA: and DQ: have been seen; missing RF:
;	COPY/DEVICE has  BPT
;	All XXDPV2 utilities use old GetLin
;	XXV076 has a DC driver
;	CALC
;	Add resources to XXRT help
;	.sbttl commas
;	f$iptr to r2
;	Finish up device names/codes
;	Write a better chain file test
;	Collect messages
;	deleted undocumented TEST command
;	use r3 to detect goto loops
;	reverse assemble PATCH, XTECO and check EMT usage
;	remove exact match to HLPINT
;	XXCPU FKAA  11/34 instruction test
;	XXTRP FKAB  11/34 traps
;	XXEIS FKAC  11/34 EIS
;	DZQK	PDP-11 instruction exerciser
;???	did xxdp cli support drs?
;???	Rewrite VM:
;???	Remove "D" command; use DIR instead
;???	Remove "U" command; R UPD2 is sufficient
;???	UPD2 cannot be named XXUPD2
;???	RK: error -- needs to be DK:
;???	UPD1 not supported (wrong driver)
;???	Check other apps for GetDrv
;???	Yuk. Deprecated EMT 43 GetDrv is used by UPD1
;???	Fill in d$puni
;???	Add system restart to documentation and HELP
;???	HELP D should only list "D", not "DCL" etc
;???	SimH tests required
;???	EXPAT documentation update
;???	Seems to work: XXHELP is broken "H xyz" displays all help
;\\\	Update XXDPP.MAC with (added)
;
;	V2
;	xtrace.bin - EMT trace for XXRT
;	Bootable XXRT
;	EXPAT retain contiguous file info with SETFILE
;	EXPAT protected
;	Check odd address for START
;	Redo system save memory allocation
;	Save XXRT across RT commands (so that Batch can use RT)
;	XXRT/V - Verbose startup
;	Copy XXRT driver CSR addresses from RT-11 drivers
;	Support XXRT/C:nnnnnn as well
;	Get DU: port/partition info
;	LD: and sub-directory support
;	Save VT setting across RT commands
;	"X dev:app" runs app from non-system device (using switch)
;	SET [NO]VT100
;	Support startup chain file
;???	H/P, D/F/P, QUIET
;	Reduce GetDev code/data footprint 
;	Cassette/Magtape???
;	VM: save/restore
;	HELP VT home and exact topic matches
;	RUST/BOOT support
;	VM: save/restore
;	API, programmers guide, internals guide
;???	No Falcon support
;	User Guide from SM/XM PDF
;	ENABLE can be done (swap back for RT-11 restore)
;	Add EXPAT DIR/DETAIL XXDP start address, load size
;	Add EXPAT DIR/USAGE=[STRING]
;	NF: for RT-11
;	Refit XXDP media monitor
;	RUST/BOOT


.sbttl	Edit History

;	DOC: IF XXX \N
;	DOC: XTECO accepts (~) and (ctrl-y) as escape
;	DOC: set default <xxdp disk>
;	DOC: R filnam[/pass][ start][ ; comment]
;	DOC: SET TT SCOPE
;	DOC: Rename RF to DF
;	DOC: <cmd<>>
;	DOC: Batch ^Z
;	DOC: Batch fail: command
;	DOC: Exert
;	DOC: Analyse /DRS/PASS/DUMP
;	DOC: Exert SHOW, system version/update
;	DOC: Internals
;	DOC: VM: usable
;	DOC: DRS naming
;	DOC: ODT
;	DOC: SET TT SCOPE
;	DOC: RT CSI apps
;
;	----------------------
;	Edit history
;	----------------------
;
;	This list is not complete.
;
;    01 01-Jan-2000 IJH	Disassemble and study XXDP+
;    02 14-Mar-2021 IJH	Complete initial source code recovery
;    03	19-Mar-2021 IJH Optimize to find space for new functionality
;			Remove XXDP boot and startup messages
;			Remove DIR command (it won't work anyway)
;			Convert to use RT-11 file system
;			Convert to start as RUST/RT application
;			(Can be booted using RUST/BOOT)
;			Add "RT" command to return to RUST/RT (MO$RTX)
;    04	22-Mar-2021 IJH More optimization to find more space
;			(All up, over 200 words have been saved)
;			Add "VT" command and VT100 support (BC$VTX/CC$VYX)
;			Support lower case input and test compatibility
;			Replace garbled error messages with full english
;			Error messages are now "?Message", not "? Message"
;			Import 50 hertz setting from host RT system
;			(Fails when booted from disk using RUST/BOOT)
;			Add startup sanity tests
;    04 24-Mar-2021 IJH	Add single-line command (e.g. "XXRT <mycommand>")
;			Change command prompt from "." to "+" (GetLin)
;    			Add initial driver collection
;    05	27-Mar-2021 IJH	Rationalize batch/rt-11 I/O interaction
;			Catch batch recursion errors (bc$chn)
;			Deprecate GetDrv
;    06	30-Mar-2021 IJH	Add "X" execute single-pass RUN command
;    08	08-Apr-2021 IJH	Change "X" execute command to "R app/QV"
;			Finish up driver collection interfaces
;			Add five more drivers to the collection
;    09 09-Apr-2021 IJH	Tediously compile media code list (XXMED$)
;			Remove auto-startup and CLI TEST command
;			(XXRT single-line commands do the same job)
;			Finish driver collection (and remove NF:)
;			Force newline before LoaFil image ident
;			CLI Start command aborts/reports odd address error
;    10 10-Apr-2021 IJH	Inherit TTKS etc TKS/TKB/TPS/TPB from RUST/RT RMON
;			Ignore TTKS etc when below @#160000 
;			Code CLI Run ^C abort but conditionalize out
;			Save more space by optimizing code 
;			Split source into XXRT.MAC and XXDRV.MAC
;			Create XXRT.DOCX
;			Elide "XXRT V3.0" startup ident (sys$c=0)
;			Elide LoaFil image ident (img$c=0)
;			V11 RT-11 VM: fails because of a V11 MMU exception bug
;			(I remember locating this bug of mine ten years ago)
;    11	11-Apr-2021 IJH	XXDP+ batch continued blindly after batch errors
;			XXRT now aborts back to CLI for all batch errors
;			This also saves some batch area space
;    12 08-May-2021 IJH	Update transcribed PDFs
;			Create XXMAC.MAC 
;			Automate initial reverse assembly of any XXDP image.
;
;    12 10-May-2021 IJH	EXT$C extends monitor by 512. words. Experimental.
;			Reorganize system data area.
;			Note: code deleted
;
;    13 14-May-2021 IJH	Add RUST command shell support RTS:RTMON/RTIMG.
;			Add command shell interface to XXRT.
;			XXRT now has most of RUST/RT as commands.
;			Add CLI and Batch SWR commands.
;			Test V11 single-line XXRT batch procedure.
;
;    15 15-May-2021 IJH	Return from XXRT resets time/date under V11.
;			Thus, V11 XXRT TIME commands are always correct.
;
;			Create XX.SYS to handle RT-11 shell commands.
;			XXRT host commands now return to XXRT under RT-11.
;			XX.SYS captures RT-11 just before it prompts and
;			instead issues exit-to-command to return to XXRT.
;			
;			API RENAMING:
;
;			Rename:  GetAvl->GetTer, GetChk->GetCha
;			Rename:  PutCha->PutTer, PutChk->PutCha
;			Rename:  GetCom->GetCfg
;			Replace: GetDrv->GetSys (XXDP/M compatible)
;
;			The earlier names were devised when I was struggling
;			to understand their distinctions. The new names are
;			closer to MACROM.MAC. XXDPP/XXDPP2 will not be renamed.
;
;			SOURCE NAMING CONVENTION:
;
;			XXDPP.MAC -> XXDPP0.MAC (unaltered)
;			XXDPP.MAC -> XXDPP1.MAC (altered)
;			XXDPP2.MAC -> same name (altered)
;
;			XXRT.MAC -> XXRT0.MAC   (unaltered as temp backup)
;			XXRT.MAC -> XXRT1.MAC   (altered)
;
;			I will rename the current source to XXRT1.MAC
;			Likewise XXDPP.MAC will become XXDPP1.MAC.
;
;    17 17-May-2021 IJH	Supress newline before prompt after returning from
;			an RT-11 host command (because RT-11 adds one).
;
;			"@@..." sends command "@..." to RUST/SJ
;
;			RUST XXHELP.SAV executes the  XXRT H(elp) command.
;			(XXHELP is the (renamed) RUST/SJ HELP image)
;			Create XXRT.HLP/HLB help library.
;
;    18 21-May-2021 IJH	Cleanup the shell recursion rules allowing XXRT
;			 to call itself back from a host command so that:
;			 <#xx def> can <def := copy f.t,sy><xx r f.t>
;			 making RUST definitions available to XXRT.
;			Batch Chain/Load/Run invalid filenames now abort
;			 Likewise start, swr
;			  ???
;    19 22-May-2021 IJH	HELP supports "C(hain)" syntax
;			Remove XXRT "@" command and "@@" hack.
;			Debug return-from-command under RT-11
;			All abort paths now check for single-line return
;			Edited RT-11 DU: bootstrap driver
;			Found more space in Batch and CLI areas
;
;			Worked out that <R DDn:file> can be implemented by
;			swapping XXRT out, RUST/RT in, copying the file to
;			"sy:temp.ib?", and then switching back to XXRT to 
;			run the temp file. Complete device independence.
;			Diagnostics no longer need be stored on SY:.
;			This will work for the batch environment as well.
;			(Although that will require me to handle up to
;			three open files at a time.)
;			This procedure will not be applied XXRT apps though.
;			However, there are no such apps at present.
;
;    20 25-May-2021 IJH	XXRT Restart address at memory top-4 (157774)
;
;    21 26-May-2021 IJH	Discard the RUST/RT boot drivers (they failed).
;			Using "literal reverse-assembly" (LRA) instead.
;			LRA is reverse assembly that uses octal addresses
;			as local location labels. Thus, <call 17456> becomes
;			call <call dd7546>, and that location has the label
;			<dd7546: ...>. Same for branches, data, etc.
;
;			Translate the XXDP monitor DU: driver and it worked.
;			Translate the DK:/RK: driver.
;
;			Parse and ignore VT100 arrow keys in VT mode.
;
;    22 27-May-2021 IJH	Translate DD: and DX: drivers. Migrate HD: and VM:
;			Find more space to support large drivers (DD:,DM:)
;			 and to support the ParSpc system service.
;
;			Remove support for apps that overwrite the monitor.
;			(along with "Use console to start" message")
;			Rationale: 28kw systems shouldn't need this and
;			 XXRT acts like an RT-11 app, not feral XXDP+.
;
;    23 28-May-2021 IJH	Translate DT: DY: DM: DP: DB:
;			Fix escape support
;			Work out how to get driver CSR addresses and DU: ports
;
;    24 29-May-2021 IJH	Revert DRS.BIN back to to HSAA.BIN because the
;			 image may be copied from varying XXDP versions.
;			Translate DR: DS: DB: PD:
;
;    25 30-May-2021 IJH	Initial driver debug and add more macros
;			Fix a lingering XXDP+ command dispatch bug
;
;    26 31-May-2021 IJH	Implement XXDP "H" and "D" commands by editing
;			 the command string (RT$DCL).
;			The RT command now remembers the system device
;	 		 unit when returning to XXRT.
;
;    27 01-Jun-2021 IJH	Fix shell for RT-11 device units.
;			Add "RUN " for RT-11 CCL commands with device names.
;			Test XXRT on RT-11 V5.0
;			Patch XXDP DU: driver for MSCP unit and partition.
;			Detect common XXDP+ driver bug <mov -2(r5)>.
;
;    28 02-Jun-2021 IJH	Add NF: driver.
;			Daily work adding stuff to XXRT HELP (DRS etc).
;
;    29 09-Jun-2021 IJH	Fixes to HELP I/F and HELP interpreter as well.
;
;    30 10-Jun-2021 IJH	Redo batch abort (because of spurious output)
;			 and combine CL$ABT and CL$CMD cleanup code
;			 in CL$ZAP.
;			Fix bugs in XX.SYS UNLOAD and elsewhere.
;			RT-11 XX UCL needs "^" ("XX :== XXRT ^")
;			Start work on EXPAT.SAV XXDP file exchange utility.
;
;    31 11-Jun-2021 IJH	Test RUST and RT-11 with all combinations of run 
;			device and XX: loaded/not loaded.
;			Change and simplify V11 API detect/call mechanism.
;			(The previous (long) version required trap catchers.
;		 	 The new (short) version uses <clc|sbcb pc|bcs true>
;			 to detect V11 and <adcb pc> to initiate V11 calls.)
;
;    29 12-Jun-2021 IJH	Simplify the "D" command to just replace D with DIR.
;			(because the fancy version was just confusing)
;			XX.SYS now sets V11 time when loaded by RT-11.
;			XX.SYS supports SET XX SYSGEN.
;
;    30 13-Jun-2021 IJH	Working on EXPAT(riate) and XXRT documentation/help.
;			EXPAT is file exchange app for RUST/RT and Windows.
;			Implementing VF, an extensible Virtual File system
;			so that I can add RSX/VMS/etc file systems to EXPAT.
;
;    31 18-Jun-2021 IJH	Continuing EXPAT and documentation/help.
;			Implement XXRT EMT API calls with arguments.
;
;    39 19-Jun-2021 IJH	EXPAT spits out its first XXDP directory under
;			RUST/SJ, RT-11, XXRT, RUST/RTX under RSX and 
;			Windows. RUST/XM fails.
;
;    39 20-Jun-2021 IJH	EXPAT supports RT-11 and Windows directories.
;			Add wildcard filename filter.
;
;    40 25-Jun-2021 IJH	TYPE command used to test basic file input for
;
;			all directory types.
;			Add native I/O for file access for local system
;			directories. 
;
;    41 31-Jun-2021 IJH	VF required moving many PDP-11 library modules to the
;			Windows library which caused all kinds of conflicts,
;			and the Windows compiler is much less forgiving.
;
;    42 07-Jul-2021 IJH	Implement COPY to native directory for RUST/RT and
;			Windows. EXPAT is now a functional import utility.
;			Windows: [XXDP]->Windows and [RT-11]->Windows
;			RT-11:   XXDP->RT-11   and RT-11->RT-11
;
;    43 21-Nov-2021 IJH	Return to work. Picked up some easy code reductions 
;			while reading XXRT.MAC for the first time in monthes.
;			A few days were spent cleaning and finishing up.
;			EXPORT needs only error messages and documents now.
;			HELP is done. The main task now is setting up test
;			environments on SimH.
;
;    44 02-Dec-2021 IJH	Add DIR/LIST to EXPAT for single column listing
;			Code reviews of all modules; Finishing up XXRT.HLP
;
;    45 04-Dec-2021 IJH	XXRT system date permanently 31-DEC-99
;			Finishing up XXAPI.MAC - XXRT API reference
;
;
;    46 27-Apr-2022 IJH	Back after long break, and as is usual:
;			o I found more redundant code/data
;			o I found assumed behaviours that were awkward
;			Rename UPD2.BIN to XXUPD2.BIN and HSAA.SYS to XXDRS.BIN
;			(All XXRT components now begin XX...)
;			Delete most of the unused conditional code
;
;    47 28-Apr-2022 IJH	XXRT documentation additions
;
;    48 29-Apr-2022 IJH	Error messages for LD: and sub-directories
;			Error if XX: not loaded under RT-11 for DCL commands
;			Disable VT100 home in XXHELP
;			Minor cleanup edits
;
;			The development phase is now essentially complete.
;			XXRT now ready for thorough sanity and debug testing.
;
;			More work required for EXPAT and HELP
;			And a lot more documentation as well
;
;			EXPAT: purge open channels after each command
;			EXPAT: add "No files found <path>" message
;
;    49 30-Apr-2022 IJH	I'm sanity checking XXRT.MAC daily at the moment
;			Fill in d$puni - which I had forgotten to do
;
;    50 31-Apr-2022 IJH	RK: needed internal renaming to DK:
;			RK: driver had wrong CSR address (174000 vs 174004)
;			HD:, RK: validated under V11
;
;    51 01-May-2022 IJH	VM: validated under V11.
;			VM: fails for diagnostics that use extended memory.
;			This bug cost me a day
;
;    51 03-May-2022 IJH	I implemented a diagnostic ctrl/c abort last year.
;			It failed because diagnostic RESETs clear the TKS
;			status, so I took the code out. However I found it
;			really irritating not to be able to stop a test
;			without rebooting the system. So I put the code back
;			in, querying the TKB directly without TKS status.
;			It's a bit iffy because some terminals might
;			conceivably clear the TKB on RESET, wrong or not.
;
;    51 06-May-2022 IJH	Now treat help "R(un)" as "Run"
;			Still sanity testing XXRT.MAC source & documentation
;			Still finding space saving optimizations.
;			Stop EXPAT reporting multiple error messages
;			Checked XTECO/PATCH for any GetDev usage issues
;
;    51 07-May-2022 IJH	Write CTS:XXLIB.MAC to interface Rider with XXRT
;
;    51 08-May-2022 IJH	XXDP+ LoaFil does not check for invalid .BIN/.BIC files
;			and may loop forever. XXRT now checks for EOF and
;			reports "?Invalid file" if so.
;
;			Add filenames to LoaFil error messages
;			Prefix batch error messages with newline
;
;    51 10-May-2022 IJH	Complete initial development package for XXRT:
;
;			XXMAC.MAC/.MLB - Macro library
;			XXSYS.D/.H - Rider definitions
;			XXLIB.MAC - Rider and C startup module
;			XXLIB contains C functions for all XXRT EMTS
;
;			Thus, XXRT supports XXDP apps in Macro, Rider or C.
;			That's right: C apps run as papertape LDA files.
;
;			XXDIAG.R/.BIN - Diagnostic to test XXRT monitor.
;			XXDIAG validates and displays XXRT internals.
;
;    52 11-May-2022 IJH	Wasted time trying to combine error message code
;			which I eventually had to back out.
;			Also got into a mess with XXLIB/etc.
;			Wasted time labelling things in XXDPSM disassembly.
;
;    53 12-May-2022 IJH	Cleaned up most of the mess I'd made of things.
;			Wasted more time decoding XXDPSM, but worked out the
;			boot issues and XXDPV2 memory structure. Sortof.
;
;			Added tests to XXDIAG.R/.BIN.
;
;    54 13-May-2022 IJH	Spent the day sanity checking, cleaning comments,
;			debugging and searching for more savings. I probably
;			saved 30 or more words today. Finally deleted most
;			of the scaffolding comments left over from the
;			reverse assembly phase.
;	
;			XXDP+/SM gets tab stop after newline wrong. Fixed.
;			I found this bug with XXDIAG.SAV.
;
;			For batch WAIT ctrl-x XXDP+ output the raw code
;			(i.e. garbage). XXDPSM skips ctrl-x output. XXRT now
;			echoes ctrl-x with a newline. I found the ctrl-x
;			issue while tracking the tab stop issue in XXDPSM.
;
;			I ran out of space in the monitor permanent area some
;			time ago. However, I've got 32. words free in the 
;			Batch and CLI overlay areas. So tonight I did the
;			awkward arithmetic to reduce the (previously fixed)
;			overlay length to give some space to the permanent area.
;			Moved some code around to fill in some gaps.
;
;			XXDP+/SM commands ignore explicit filetypes, such as
;			Z.XXX, except for six letter filenames, such as
;			123456.XXX. Fixed for XXRT.
;
;			The XXDP batch command search algorithm crashes the
;			system for terminator-only commands. XXRT skips
;			leading spaces and reports a batch error for any
;			other terminator only command.
;
;			The system restart procedure was only present in memory
;			in CLI mode. Activating system restart in batch mode
;			jumped into random code and crashes. XXRT fixes this
;			problem by reloading the CLI during system restart.
;
;    55 15-May-2022 IJH	Remove copying TKS/TKB/TPS/TPB from RUST/RT. XXDP
;			relies on the bog standard addresses. Saves some
;			space as well.
;
;			HD: driver crashed because of wrong register restore
;			order. Now validated for RUST.
;
;			Fixes to EXPAT that revealed a 'lurgy' bug. A lurgy
;			is a bug that modifies memory that it shouldn't
;			but that is not directly debuggable. However
;			the code that triggers the bug (vf_att in vfdrv.r)
;			is due for a full rewrite anyway. Tomorrow.
;
;    56 17-May-2022 IJH	Fix EXPAT bug. It was my first string buffer overrun 
;			bug in twenty years!
;
;			I'd left the init low/high procedures more or less
;			unchanged from XXDP+. Rationalizing them provides
;			more clarity and more space. Major surgery here.
;
;			Corrected LoaSup CLI exit path to jump to cl$eng
;			rather than cl$cmd because cl$eng restores CLI
;			context (stack, emt vector and PSW).
;
;			Saved yet more space.
;
;    57 18-May-2022 IJH	XXDIAG was displaying corrupt information after
;			running a batch file. I'd moved GetSys etc to
;			the delicate no-mans-land area that is required
;			for maintaining XXDP's delicate memory architecture.
;			I forgot that GetSys used movr and that was
;			overwritten by rereading the CLI overlay.
;
;			XXDP restored the CLI overlay by reading into the
;			overlay area directly. XXDP never uses partial block
;			reads, thus the CLI read reread a few hundred bytes 
;			bytes following the overlay. XXRT now reads the CLI
;			overlay into the batch region and copies up to the
;			CLI overlay making it much easier to manage the memory
;			architecture.
;
;			Lots of cleanup. Save more space. Fix EXPAT issues.
;
;    58 23-May-2022 IJH	Debug using XXDIAG to check system variable sanity. 
;			Fixes to RUN/QV and batch invalid command.
;			Use relocated addresses to compress EM$ENG.
;
;			XXDPXM terminates a batch image with ctrl-c and
;			aborts batch completely with ctrl-z. Not sure if
;			XXDPSM has this support. Added to XXRT.
;
;			I missunderstood the role of Batch /<passes> and /QV.
;			CLI <r filnam/QV> is replaced by a default repeat
;			count of one. CLI <r filnam/5> runs a diagnostic
;			five times. CLI <r filnam/QV> is gone. Batch and
;			CLI are identical now.
;
;			XXDPXM <IF ^C THEN> added to XXRT Batch (from XXDPXM)
;
;    59 24-May-2022 IJH	Combine duplicated code in cc$chn and mo$chn.
;			Rewrite EMT dispatcher to use relocated dispatch list.
;
;			Change "?Batch error" to "?Batch abort"
;
;			Reset default command line for Batch command loop.
;			XXDP does this only for the CLI command loop. XXDP
;			Batch uses the DRS command line buffer (in the 
;			middle of nowhere) after DRS exits.
;
;			A lot more code compression and general source
;			cleanup and reorganization.
;
;    60 25-May-2022 IJH	Rewrite BU$ACT/BU$RET etc. to save space and 
;			orthoganalize with CU$ACT etc.
;
;			Fix EXPAT COPY bug (cu_asc () error).
;			Add EXPAT DIR contiguous flag for XXDP files.
;			Format EXPAT directory file specs to align types.
;    61 27-May-2022 IJH	Contiguous file COPY support for EXPAT XXDP files.
;
;			Finally identify the purpose of the GetCom location
;			following S$YCSR, which XXDP does not access, as
;			the system device controller (now labelled S$YCON).
;			DRS uses S$YCSR, S$YCON and S$YUNI to check whether
;			the media being tested is the same as the system
;			device.
;
;			After dithering for a long time, revert XXUPD.BIN
;			back to UPD2.BIN and revert XXDRS.BIN back to
;			HSAA??.SYS (to make it less confusing when using
;			XXRT with non-system RT-11 disks).
;
;    62 28-May-2022 IJH	Ignore leading spaces and tabs for Batch commands.
;			Start writing a Batch test suite.
;
;			XTECO fails because <esc> is elided by XXRT GetCha.
;			Solution is to elide <esc> only in CLI mode and
;			only when GetLin is calling GetCha. Unfortunately
;			this removes escape support from DRS and UPD2.
;
;			Begin updating and finishing XXRT.HLP.
;			Add HELP for XTECO.
;
;			Sketch minimal RT-11 EMT handler for XRTLIB.MAC.
;
;    63 29-May-2022 IJH	Change <esc> test to exclude filtering if c$llin
;			points to an address below the supervisor. This
;			gives all utilities <esc> support except for
;			XTECO and PATCH. This method is a bit iffy.
;
;			Change "?Batch abort" to "?Batch error: " and
;			append the command line to error messages. Without
;			this Batch debug is ridiculous.
;
;			Remove XXRT U(pdate) command. 
;
;			Add help for PATCH and SETUP. Reorganize XXRT.HLP.
;
;			XRTLIB.MAC EMT support now handles .GTLIN plus others.
;			Enough to add DCL support to XXDIAG. Rename XXDIAG
;			to XERT, the XXRT Exerciser.
;
;    64 30-May-2022 IJH	XRTLIB integration with DCL interpreter complete.
;			I can develop easily for the XXDP environment using
;			Rider/C and all it's applicable libraries.
;
;			Replace "?Invalid filename: ..." with "?Invalid
;			command: ..."
;
;			In fact, ctrl-c should not abort batch. Fixed.
;			[Later: wrong, sometimes it should, sometimes not]
;
;			XXDP did not reset the stack at BA$CMD (as
;			CL$CMD does). Because of this multiple ctrl-c
;			aborts crashed the stack overwriting the GOTO
;			switch area. Fixed.
;
;    65 31-May-2022 IJH	Add ANALYSE to EXPAT to display LDA files low,	
;			high and start locations along with contents
;			of 200:202. Finding EXPAT bugs at the same time.
;
;			Early on I missunderstood B$AFNM and B$ASFN to
;			be rad50 rather than ascii file specs. Corrected.
;
;    66 01-Jun-2022 IJH	Finish debugging ANALYSE (which will be renamed).
;			Use ANALYSE to answer a couple of questions I've
;			had forever (which is why ANALYSE was written).
;
;			1. Do any diagnostics overwrite the transient area
;			   of a 28kw environment? No they don't. The largest
;			   image, DEC/X11 image, doesn't exceed 140000.
;
;			2. How many diagnostics overwrite 0:1000? Many.
;			   These are the earliest apps that were originally
;			   papertape diagnostics.
;
;			3. What is the memory footprint of DRS-enabled
;			   diagnostics? All DRS apps have a low address of
;			   2000.
;
;			Report more parsing errors that Batch ignored.
;
;    67 02-Jun-2022 IJH	Generalize EXPAT directory processing to avoid
;			repeating it for every command. End up fighting
;			DECUS-C problem with function pointers. Again.
;			Finally solved after 20 years.
;
;			Use ANALYSE to understand a lot more about XXDP
;			executable images. Document findings at LoaFil.
;
;			XXDIAG and ANALYSE are being used to rivet-test
;			XXRT.
;
;    68 03-Jun-2022 IJH	INDEX command searches a database derived from the
;			1988 Diagnostic Handbook for diagnostics matching
;			a wildcard search string. However the PDF-to-text
;			is imperfect (0 becomes O, 1 becomes l (lower case
;			L), etc. Still the idea works and can be linked to
;			the directory operation. Fast on Windows, really
;			slow on a real PDP-11.
;
;    69 04-Jun-2022 IJH	Remove XXRT user documentation from XXRT.MAC and 
;			XRT.HLP and create XXRT.DOCX (to be renamed) to
;			hold all such documentation. Good simplification.
;
;			Extended ANALYSE to detect apps that use the 
;			mechanism that supports RUN/PASS as described at
;			BU$RET. See notes there. Joerg Hoppe's diagnostic
;			database simplified what would have otherwise been
;			sheer torture in locating diagnostic sources.
;
;			Noted that XXDP+ never clears S$YQVS meaning that
;			<C myfile/qv> affects all subsequent chain operations.
;			Only a reboot would clear it. Same for XXDPV2.
;			Tested this under XXDP+. XXRT already had the fix.
;
;    70 05-Jun-2022 IJH	Implement O(DT) command. Mini-ODT has replace, 
;			advance and backup. I wanted to do this earlier in
;			the project but didn't have the space back then.
;			Now I have the space and I can only use it for
;			CLI commands.
;
;			ParOct did not always return terminator. Fixed.
;
;			Used ANALYSE and Hoppe to work out more about the 
;			@#52 and the logic of the SMI/CMI protocol. Many
;			diagnostics set values in @#52, but they're always
;			literals with no useful symbolic information.
;
;    71 06-Jun-2022 IJH	Replace CLI SWR with the shorter Batch version.
;			ODT replaces the interactive use.
;
;			Remove VT command. Replaced by RT-11 SET TT SCOPE.
;			Remove Update command. It's superflous.
;
;			The savings compensate for the rather expensive
;			implementation of ODT. The CLI command set is also
;			simplified. And I can use some of the saved space
;			to do address checks for ODT memory accesses.
;
;			Setup a regulated XXRT.MAC etc source history
;			archive in XRS:\HIS\.
;
;    72 07-Jun-2022 IJH	Add functionality to ODT.
;
;			A few passes across the source eliding hanging
;			local branch labels and converting local symbol 
;			blocks into named functional labels, etc.
;
;    73 08-Jun-2022 IJH	Rename CLI command routines from CL$xxx to CC$xxx
;			(CL$RUN becomes CC$RUN). Orthogonality be thy name.	
;
;			Move all impure data in the Batch and CLI overlays
;			into the system data area, to whit: b$astk, b$ustk
;			and c$ustk. All the code preceding the system data
;			area is now pure.
;
;			Cleaned up TE$CTX and TE$CTL. The comments and the
;			code had long standing major disagreements.
;
;			Cleanup all local symbol blocks, renumbering, and,
;			deleting a dozen or so unused labels (many dating
;			back to the transcription).
;
;			Test and document XXDPV1/SM/XM/RT Batch with 
;			GOTO0/RUNP/SYNTAX/WAIT.CCC for differences.
;			In particular for ctrl-c, ctrl-z differences.
;
;    74 09-Jun-2022 IJH	Reorder Batch routines functionally (more or less).
;			Comment editing and other decoration.
;
;			More Batch ^C protocol testing with XXDPV1/V2.
;			Involves more test chain files and more deep 
;			dives into XXDPXM.DIS.
;			
;			Create an RT-11 RL02 (PDP:XXRT.DSK) with all the
;			files from XXDP23.DSK and run XXRT on that. No
;			need to copy diagnostic files anymore.
;			
;			Improve EXPAT ANALYSE:
;
;			o /DRS/PASS select associated files.
;			o /DUMP now handles the detailed info.
;			o The default is now a summary.
;			o Entries now include a diagnostic description.
;			  (If one is available in XINDEX.TXT).
;
;			Still saving space regularly.
;
;    75 10-Jun-2022 IJH	Batch error messages for GOTO did not display
;			the offending command because it was overwritten
;			by the label search. Create a temporary buffer
;			just below the resident monitor to solve the
;			problem. A hack.
;
;			Change LoaFil error messages from TypMon to 
;			TypBrk. Also solves a conflict with the new CLI
;			message system that includes command strings. 
;			Common code with DR$OPN, thus saving space.
;
;			Created "XXRT Internals.docx" to record all the
;			gory details of XXDP's inner life.
;
;			Running XXRT on VM: has failed in the past because
;			extended memory was being modified by some
;			diagnostics. In fact, XXDP+ DRS was the culprit.
;			XXDP+ DRS used a destructive tests to work out
;			how much extended memory was present. V2 DRSSM
;			uses a non-destructive test and is compatible
;			with XXDP+.
;
;			It dawned on me while testing HSAA and DRSSM
;			that I have a problem with LoaSup. On some 
;			disks the supervisor with be HSAA??.SYS, on
;			others DRSSM.SYS. The solution is to back to
;			using DRS.BIN. See the internals guide.
;
;			Filled in the (added) markers for code I hadn't
;			marked. Total is about seventy.
;
;    76 13-Jun-2022 IJH	<XXRT cmd\> does not return to RUST/RT. Likewise
;			<RT cmd\> does not return to XXRT.
;
;			Batch IF had the same problem as GOTO as noted
;			above (edit #72). Fixed the same way as GOTO.
;
;			Relocate XXRT system data to follow the driver
;			data so that additions to XXRT date don't affect
;			driver offsets.
;
;			Add s$yver/s$yupd to record XXRT version number.
;			XXRT begins with V3.0, treating XXRT as a 
;			successor, of sorts, to V1 and V2.
;
;			Add XERT SHOW command. Not much to say.
;
;			Found the original version of XXRT.MAC finished
;			one week after the transcription was completed.
;
;    77 13-Jun-2022 IJH	Change <command\> to <commmand<>> because of			lexical ambiguity with, say, "dir xx:\sub\".
;			lexical ambiguity with, say, "dir xx:\sub\".
;			In fact all single character terminators are 
;			potentially ambiguous, thus two characters.
;		
;			Rename XERT.SAV back to EXERT.SAV. I found "XERT"
;			awkward.
;
;			I wasn't sure if the RF11 was labelled "DF:" or
;			"RF:". The DOS11 sources resolved the issue: it 
;			was "DF", so I've renamed it thus.
;
;			XXDP GetLin returns a nonsense command line if
;			EOF is detected in Batch mode. Most apps ignore
;			GetLin EOF resulting garbage-in-garbage out.
;			XXRT returns a null line.
;
;			DRS loops forever at its prompt for Batch EOF.
;			Ctrl-z now aborts any batch file that happens
;			to issue GetLin.
;
;			Change "?Batch error:" back to "?Batch abort:"
;			Yet again.
;
;			Avoid rereading the CLI overlay if its already
;			in memory for a system restart (using the code 
;			at the first word of the Batch and CLI areas
;			as a detection signature). See XX$RST.
;
;			I foundI HMDLC1.SYS, an earlier version of XXDP+
;			than the HMDLD1.SYS I'd transcribed. It was really
;			easy to compare the two because: (1) the changes
;			had all been developed as patches which only
;			altered small segments of code (mostly), and (2)
;			because SRCDIF.SAV, which I wrote a decade or
;			more ago displayed the code really well in 
;			/PARALLEL mode with /WIDTH:110. Changes are noted
;			in XDS:XXDPP2.MAC. The lingering mystery of the
;			placement of DU$RES in XXDPP2.MAC was solved: it
;			was added as a patch at end-of-file.
;
;			EXPAT commands missing type specs were not
;			reported as errors. Error fixed in rls:dcmod.r
;
;			Use RUST/TT <SET TT [NO]SCOPE> setting to 
;			configure s$yscp (was s$yvtx).
;
;			Add CLI "X" command to run EXERT directly.
;
;    78 14-Jun-2022 IJH	Oops. I incorrectly labelled ParOct as a skip
;			return during transcription. At some
;			point I obeyed that and optimized ParOct for
;			a skip return. Reverted to a cbit return.
;
;			I caught the above while tracking V1/V2 compatibility
;			of skip/cbit returns (it's an ugly story). Created
;			lists of uses for V1/V2/V3.
;
;			Note: V1=XXDP+, V2=XXDPSM/XM, V3=XXRT.
;
;			Added TRAPS command to EXERT to reset all low
;			memory traps except the EMT vector. EXERT is now
;			obeying parkinson's law.
;
;			EXERT was corrupting low memory because the binary
;			link of EXERT did not set RT-11 j$btop which was 
;			used by ME$ALC to map memory. Used .LIMIT to solve
;			the problem. Problem detected testing TRAPS.
;
;			XRTLIB now implements single-line commands for the
;			"X" command. Thus <X SHOW> is equivalent to 
;			<R EXERT><SHOW>. Parkinson continues.
;
;			Single-line EXERT has to inhibit CLI NewLin just
;			as return-from-shell does, for which I can use the
;			same flag, S$YNEW. Doing that I found a bug in the
;			MACRO and Rider/C syscom definitions. Eat-you-own-
;			dog-food is the only way to test operating systems.
;
;			A couple of hours spent clearing up the MACRO and
;			Rider/C definitions of the syscom and driver areas.
;			areas.
;
;			Finish EXPAT equivalent of <SETUP LIST ...> by
;			comparing output. Fix one bug. SETUP jumps through
;			hoops to arrive at what I get simply by comparing
;			location @#2100 with 0104035 (LoaSup). Perhaps
;			its doing some other tasks...
;
;			Implemented DCL-style CLI names, as XXDPXM does,
;			with minimal abbreviations. Thus, "C*HAIN* etc.
;			I'll try it out for a few days. The thing is, ODT
;			might have go as, combined together, the static
;			area only has a few words free. However, I might
;			have another trick up my sleeve to get ODT back in.
;
;    79 15-Jun-2022 IJH	ODT is back in, located in the unused gap between
;			the end of the Batch overlay and the start of the
;			static region. The CLI ODT command first makes sure
;			that Batch overlay is present in the Batch region
;			and then calls OD$ODT there. Five minutes work.
;
;			CU$CND previously sat just outside the overlay
;			region where it was called in common by CLI
;			chain and Batch IF. Fold separate copies into
;			the overlays. Saves a little space and cleans up
;			organization.
;
;			Sometimes it should be "Batch error" and sometimes
;			"Batch abort". Trying "Batch fail", which captures
;			both.
;
;			Shuffled routines between regions to gather things
;			together in functional groups.
;
;    70 16-Jun-2022 IJH	Inherit $SYNUB qbus/unibus state from RUST/RT config2.
;
;			Testing Batch has required tediously creating test 
;			.CCC batch files. A new maintenance "B*ATCH" command
;			runs Batch from the console, not a batch file.
;
;			Batch ctrl-z no longer reports the command line.
;
;			More reorganization of routines and comment cleanup.
;
;    71 17-Jun-2022 IJH	EXPAT DIR/XXDP now lists XXDP ANALYSE information.
;
;		        .CNF files are also formatted binary, but have a
;			single record only.
;
;			Created a new utility, CRACK.SAV/.EXE, which
;			analyses file structures. Long planned. Some DUMP
;			functions will move there.
;
;			The detailed ANALYSE commmand is misplaced in EXPAT
;			and will eventually move to CRACK.SAV.
;
;			Resuscitating an .OBJ file analyser from many years
;			ago for CRACK. Also on the ToDo list for years.
;
;			Improve DUMP/INSTRUCTION/SKELETON and patch
;			DIFFER (SRCDIF.SAV) to ignore digits to compare
;			XXDP+ and XXDPSM reverse assemblies. It actually
;			picks up a lot of the common code.
;
;    72 18-Jun-2022 IJH	EXPAT cleanup. Divide Windows file sizes greater
;			greater than 65535 blocks by 1024 and append (k).
;
;			For COPY, copy input file time to output file
;			time unless COPY/SETDATE which copies the current
;			date/time to the output file. Required harmonizing
;			the PDP-11 and Windows libraries.
;
;			Generalizing the VF interfaces developed in EXPAT
;			to library routines for use in other cusps, CRACK	
;			in particular.
;
;			Used ANALYSE to reports the longest diagnostic on
;			a disk. Neither of the files below reaches the
;			transient boundary (150000) or even the batch
;			region (146000).
;
;			x23:jkdjb0.bin 133452 - crashes on V1/V3, not V2
;			x25:epomur.bin 145160 - unlisted DEC/X11 monitor
;
;			Used ANALYSE to report the longest LDA segments:
;
;			.bi?:  509
;			.sys:  509
;			.cnf:  884 (single record)
;			.lib:   46
;			.map: 4640
;			.obj:  126
;
;    73 19-Jun-2022 IJH	Clean up the messy EXPAT LDA code and displays.
;			Report number of EMTs and MMU accesses (sort of).
;
;			The LDA analyser recognises and ignores non-LDA
;			files and also discriminates between non-LDA
;			formatted binary files.
;
;			Some EXPAT XXDP processes will take forever on
;			real PDP-11s because the text file searches.
;
;			All the EXPAT XXDP commands are now subsumed
;			by DIR/XXDP/ETC qualifiers.
;
;			x23:jkdjb0.bin (reported above) crashes because
;			it sets its EMT vector to point to an error
;			report routine and then reports errors using
;			EMT 0. DIR/XXDP reports this spin loop (S=n rather
;			than E=n--and it's the only instance seen).
;			  The remaining mystery is why it survives under
;			XM. XM plays games with the EMT vector when 
;			activating an image.
;	
;			Regular daily session decoding SM or XM or other.
;			It just gets wierder.
;
;    74 20-Jun-2022 IJH	EXPAT needs to access XINDEX.TXT to list XXDP
;			descriptions which requires working out the
;			directory path of EXPAT. That's easy with Windows
;			(GetCommandLine), however RUST and RT-11 make it
;			difficult. Lots of RUST and RT-11 magic required.
;
;			EXPAT had grown too large as a single PDP-11 app.
;			Split it into overlays and then deal with all
;			problems harmonizing RUST/RT and Windows. Now
;			about 5kw shorter. It's now 12kw (including a 
;			1.5kw stack); that's much better than I expected
;			and means I'll enough space to do the export
;			code (in a second overlay region). 20kw is max.
;
;    75 22-Jun-2022 IJH	Add /EXCLUDE=spec to EXPAT. More cleanup.
;
;			Start cleaning up the mess I made of BOOT.R a few
;			years ago. Other messes await from the same period.
;
;			Suddenly XXRT crashed running FKAA??.BIC. Many
;			hours spent tracking this down. I had moved my
;			RUST/SJ from an RL01 .DSK shell to an RL02 shell
;			It turns out that that shell had an HD: driver
;			not an RL: driver and that the XXRT driver I'd
;			I'd cobbled together was using definitions that
;			enabled HD: interrupts.
;
;			Moved RUST/SJ to an existing RL02 .DSK shell.
;
;    76 24-Jun-2022 IJH	Cleaning up SRCDIF inability to report and recover
;			from overflow errors.
;
;			RV_PDP now reverse assembles <mova adr,r0> and
;			<psha adr>. Applies to V11 debug, PATCH and
;			DUMP/INSTRUCTION/DISASSEMBLE.
;
;    77 06-Jul-2022 IJH	Working on EXPAT and other things the last few days.
;			Fixing up a lot of broken RUST software as well.
;
;			Digging into XXDPSM/XM and diagnostics to see 
;			whether any X25 diagnostics actually use the new
;			features present in XM. I couldn't find any and
;			I suspect that most of the new functionality is
;			reserved for use by DEC acceptance testing processes.
;
;			Update XXRT to HMDLE0. I already had the two 
;			relevant updates in place from debugging.
;
;    78 09-Jul-2022 IJH	Retract CLI minimal abbreviations. Not worth the
;			or the updates to HELP. Don't use EXPAT for DIR.
;
;    79 26-Aug-2022 IJH	Various undocumented fixes and space saves over the 
;			last week or so.
;
;			Fold TypBrk into TypMsg. Saves space.
;
;			Rewrite ParOct to report an error for a null digit
;			string.
;
;			Fully rewrite ODT. Batch now supports ODT.
;
;			SWR command is deprecated. Use <#odt 176=nnn/>.
;
;    79 27-Aug-2022 IJH	Extensions to ODT.
;
;    80 29-Aug-2022 IJH	ODT is now getting difficult to manage within XXRTs
;			space constraints, thus:
;
;			Add a new overlay to XXRT. Located on disk at the
;			end of the resident monitor. This overlay is copied
;			to the batch region, where it also executes. Further
;			overlays could be added using the same method.
;	
;			I tried to extend the monitor a year ago but failed
;			because memory save/restore failed for reasons I
;			couldn't work out. Tonight I worked them out.
;
;    81 31-Aug-2022 IJH	Finish new ODT.
;
;			Many new commands/options have been added to EXPAT.
;
;	COPY MONTH
;
;    79 00-Jun-2022 IJH	
;    79 01-Jun-2022 IJH	
;    76 02-Jun-2022 IJH	
;    76 03-Jun-2022 IJH	
;    77 04-Jun-2022 IJH	
;    78 05-Jun-2022 IJH	
;    78 06-Jun-2022 IJH	
;    78 07-Jun-2022 IJH	
;    78 08-Jun-2022 IJH	
;    78 09-Jun-2022 IJH	
;    79 10-Jun-2022 IJH	
;    79 11-Jun-2022 IJH	
;    76 12-Jun-2022 IJH	
;    76 13-Jun-2022 IJH	
;    77 14-Jun-2022 IJH	
;    78 15-Jun-2022 IJH	
;    78 16-Jun-2022 IJH	
;    78 17-Jun-2022 IJH	
;    78 18-Jun-2022 IJH	
;    78 19-Jun-2022 IJH	
;    79 20-Jun-2022 IJH	
;    79 21-Jun-2022 IJH	
;    76 22-Jun-2022 IJH	
;    76 23-Jun-2022 IJH	
;    77 24-Jun-2022 IJH	
;    78 25-Jun-2022 IJH	
;    78 26-Jun-2022 IJH	
;    78 27-Jun-2022 IJH	
;    78 28-Jun-2022 IJH	
;    78 29-Jun-2022 IJH	
;    79 30-Jun-2022 IJH	
;    79 31-Jun-2022 IJH	



.sbttl	conditionals

mcp$c=1		; mscp fix
map$c=1		; save/restore fix
ext$c=1		; extended overlay
odt$c=1		; new odt code
		;
brn$c=1		; Batch run .cc?
gto$c=1		; goto buffer (iffy, being tested)
swi$c=1		; check chain switch "/" syntax
		;
abr$c=0		; command abbreviations
ret$c=0		; bu$ret elision
		;
bat$c=1		; B Batch maintenance command
dbg$c=0		; BPT maintenance debug command
xrt$c=0		; X maintenance command (EXERT)


.title	XXRT - XXDP meets RT-11

;	-----------------------
;	XXRT - XXDP meets RT-11 
;	-----------------------
;
;				N O T E
;	   This is the first release of XXRT. It has been tested 
;	   under SimH.
;
;	XXRT migrates the XXDP+ monitor to run in an RT-11 host environment
;	with diagnostics stored in RT-11 directories. XXRT users may issue
;	both XXDP and RT-11 DCL commands. XXRT does this by switching
;	between between the RT-11 and XXRT monitors.
;
;	XXRT is a modified version of the reverse-assembled XXDP+ monitor
;	source code. See github.com/rust11/xxdp/ for that project.
;
;	Improving the XXDP user interface has been a strong goal. More error
;	conditions are detected and error messages are more sensible. An 
;	extensive HELP facility and rudimentary XXDP file import utility
;	are included.
;
;	XXRT has full support for DRS and XXDP batch scripts. Native XXDP
;	utilities, such as UPD2, PATCH, etc, may be used, but can only 
;	operate with XXDP disks and tapes.
;
;	Some functionality changes in the later XXDP/SM and XXDP/XM monitors
;	have been migrated to XXRT. New XXRT commands include 'SWR' which
;	is used to set the software switch register, and 'RT', which sends
;	a command to RT-11, or returns to RT-11.
;
;	.xxrt			! start XXRT under RT-11
;	#			! XXRT prompts for a command
;	#r zabdd0		! run a diagnostic
;	#c mycmds		! start a batch file
;	#copy dl1:zbff??.bic sy:! use RT-11 DCL to copy a diagnostic
;	#r zbff??		! run the diagnostic
;	#rt			! return to RT-11
;
;	XXRT can also be used in single-line command mode:
;
;	.xxrt r zabdd0		! run a diagnostic
;				! diagnostic runs
;	.			! control returns to RT-11
;
;	New features include:
;
;	o Lowercase terminal input and VT100-mode rubout.
;	o The SWR command manipulates the XXDP sofware switch register. 
;	o XXRT provides an extensive interactive HELP facility.
;	o EXPAT provides an RT-11/XXDP file exchange facility.
;	o Improved error checking, messages and recovery.
;
;	XXRT supports the following V5.x RT-11 systems:
;
;	RT-11/SJ  RT-11/SB  RT-11/FB  RUST/SJ*
;
;	o XXRT is supported on RT-11 V5.3 and later, and RUST/SJ.
;	o Mapped RT-11 systems (RT-11/XB/XM/ZB/ZM) are not supported.
;	o XXRT has been tested under the SimH and V11* PDP-11 emulators.
;
;	* RUST/SJ and V11 are my RT-11 and PDP-11 emulator implementations.
;
;	XXRT supports the following runtime devices:
;
;	DB: DC: DD: PD: RF: DL: DK: DM: DP: DS: DT: DU: DX: DY: HD: VM: 
;
;	Note: DK: is the XXDP name for the RT-11 RK: device.
;	Note: Only DL:, DK: (aka RK:) and DU: have been tested.
;	Note: VM: fails for diagnostics that use extended memory.


.sbttl	Implementation

;	--------------------
;  	Virtual Machine
;	--------------------
;
;	XXRT initiation and exit procedures are summarized below:
;
;	RT-11 layout:		XXRT layout:		XXRT disk image:
;	
;	+---------------+	+---------------+	+---------------+
;	| RT-11		|	| XXRT monitor	|	| RT-11	image	|
;	+---------------+	+---------------+	+---------------+
;	| Drivers etc.	|	|		|	| Drivers etc.	|
;	+---------------+	|               |	+---------------+
;	|		|	|		|
;	| XXRT monitor	|	| (Utilities)	|
;	| XXRT init/exit|	| (Diagnostics)	|
;	+---------------+	+---------------+
;
;	Initiating XXRT:
;
;	1. RT-11 executes XXRT.SAV as an application
;	2. XXRT copies the RT-11 monitor and drivers to the disk image
;	   The disk image is located in a reserved area of XXRT.SAV
;	3. Init relocates the XXRT monitor to the top of memory
;	4. Init passes control to the XXRT monitor
;
;	Exiting XXRT:
;
;	1. The XXRT monitor rereads the exit code into low memory
;	2. The exit code reads RT-11 back into memory
;	3. The exit code restores RT-11 to memory top
;	4. The exit code returns to RT-11 (with an optional command)
;
;	Note: XXRT assumes that a system will have sufficient memory
;	      for this operation.
;
;	--------------------------
;   	File System Migration
;	--------------------------
;
;	The major task for XXRT is to replace the XXDP file structure with
;	an RT-11 file structure. It wasn't entirely clear if the replacement
;	would work, in particular for sequential file input. The question was
;	this: did XXDP have optimizations (hacks) which relied on an internal
;	knowledge of the file system? If it did then the migration would 
;	almost certainly fail.
;
;	XXDP is in fact file-system-independent because it has to support both
;	disks and magtapes. Because of this the monitor and utilities are
;	forced to follow strict usage protocols, and they do. That was the bit
;	of luck needed for success.
;
;	OpnFil
;	------
;	The first task was to replace the OpnFil and DR$OPN routines.
;	XXDP uses a single 256-word buffer to process directories where
;	RT-11 directory segments occupy a 512-word buffer. However, 
;	it's not difficult to do RT-11 lookups using a sequential approach
;	treating directory entries as sequential records. See "DR$OPN:".
;
;	ReaBlk
;	------
;	The second task was the potential critical point of failure. The
;	XXDP disk file structure reserves the first word of each 256-word
;	block for a pointer to the next block of the file. End-of-file is 
;	signalled by a zero pointer.
;
;	RT-11 has a contiguous file structure, so the "next block" is always
;	the current block plus one. RT-11 stores the file length to detect
;	end-of-file. The code below mimics the XXDP strategy. This approach
;	has worked seamlessly.
;
;ReaBlk:mov	dr.buf(r5),io.buf(r5); buffer
;	mov	#256.,io.wct(r5); word count
;	call	@dr.tra(r5)	; transfer 
;
;	Mimic XXDP file structure behaviour
;
;	mov	io.blk(r5),r2	; r2 = the current RT-11 block
;	inc	r2		; r2 = the next block
;	cmp	r2,f$ilst	; at or past the last block?
;	blo	10$		; no - we're good
;	clr	r2		; yes - signal EOF
;10$:	mov	r2,f$inxt	; store next block
;
;
;	DR$RST
;	------
;	XXDP has a separate function, DR$RST (monitor restore), to re-read
;	monitor overlays into memory. There are two reasons:
;
;	First, the monitor is a contiguous file and can't be processed by
;	record-oriented XXDP Get/Put system calls.
;
;	Second, the XXDP CLI Enable command allows a user to switch system
;	disks while the system is running. To do this DR$RST must read the
;	MFD to workout the disk location of the monitor.
;
;	XXRT does not support system disk switching (the E(nable) command).
;
;	XXRT is a RUST/RT application not a stand-alone O/S. Adding Enable
;	Enable functionality would make it near impossible to support a
;	return to the host RUST/RT system.


.sbttl	Driver Collection

;	----------------------
;	XXDP Driver Collection
;	----------------------
;
;	XXRT automatically matches the driver with the device and unit
;	where the save image resides. Thus, "R RK1:XXRT" loads the RK:
;	driver. XXRT supports the following drivers:
; 
;	DB: DC: DD: RF: DL: DK: DM: DP: DS: DT: DU: DX: DY: HD: PD: VM:
;
;	Most of the drivers are based on a "literal" reverse-assembly of
;	the XXDP+ drivers. The exceptions are DC:, RF:, HD: and VM:
;
;	DRIVER SUPPORT
;
;	o The XXRT image device driver must be LOADed.
;
;	TRANSLATION:
;	XXRT drivers were extracted from the XXDP+ monitor images using
;	"Literal Reverse Assembly" (LRA). LRA does not attempt to comment
;	the code or add symbolic labels.
;
;	LRA was possible because all but one of the XXDP+ monitors are
;	binary exact duplicates of the same monitor code. The exception was
;	the DU monitor which had a number of small changes to the monitor
;	code (which I haven't investigated). However, it appears that these
;	changes were unrelated to the DU: driver itself. They were 
;	probably bug-fixes.
;
;	TESTING:
;
;	Manual translation expects errors.
;
;	VM: WORKAROUND:
;
;	DRIVER NOTES:
;
;	DU: - MSCP disk.
;	o For RT-11 drivers, MSCP unit and partition information is 
;	  acquired from the RT-11 driver and transferred to the XXRT driver.
;
;	  There is currently no way in which the CSR associated with a 
;	  port can be acquired from the driver.
;
;	o XXRT changes the MSCP ring structure. To make sure that the RT-11
;	  reinitializes, XXRT always leaves the MSCP in an unititialized
;	  state.
;	
;	PD: - PDT DD:
;	o PDT DD: is supported, however I do not have anyway of testing
;	  this driver.
;
;	VM: - Virtual Memory driver
;	o VM: is an XXRT additional driver.
;	o VM: is 


.title	XXRT - XXDP meets RT-11
.include "lib:rust.mac"	; Standard RUST/SJ preface
.library "lib:drvmac"	; Driver macros and definitions

;	Macro and symbol definitions (sms:ld?.mac)

$chdef		; rt-11 channels
$cndef		; rt-11 config
$cidef		; rt-11 cstat info
$dcdef		; rt-11 device codes
$didef		; rt-11 dstat info
$ehdef		; rust/sj  header
$emdef		; rt-11 emts
$hadef		; rt-11 handlers
$jbdef		; rt-11 job
$jsdef		; rt-11 job status word
$kwdef		; pdp-11 clocks
$mmdef		; pdp-11 memory management
$rmdef		; rt-11 rmon
$tcdef		; rt-11 terminal config
$vedef		; pdp-11 vectors
$vrdef		; V11 emulator

;	Conditionals


;	RUST/SJ build procedure:
;
;	%build
;	macro xrs:(xxrt+xxdrv)/object:xrb:xxrt
;	link xrb:xxrt/exe:xrb:xxrt/map:xrb:xxrt/alpha
;	%end


.sbttl	System service EMT API					(data)

;	XXDP API
;
;	o XXRT updates the XXDP+ API to XXDPSM.
;	o Otherwise, XXRT makes no changes at all to the XXDP+ API


;	API is the simple case, no arguments

	.MACRO	API NAM COD
	 .macro	nam
	   emt	cod
	 .endm
	.ENDM

;	APIR0 picks up a single R0 argument
;
	.MACRO	APIR0 nam,cod,mod
	  .macro nam,obj
	    mov$ obj,r0,mod
	    emt	 cod
	  .endm
	.ENDM


;	APIA handles more complex addressing.
;
;	XXDP has three addressing modes for EMTs arguments: generic,
;	position-independent and relocated. The APIA macro handles
;	these as below (using SetLin as an example):
;
;	SetLin	adr		; MOV  adr,r0 - generic
;	SetLin	adr,A		; MOVA adr,r0 - position-independent
;	SetLin	adr,R		; MOVR adr,r0 - relocated

	.MACRO	MOV$ ADR,REG,MOD
	  .if nb <adr>
	    .if dif <adr>,<reg>
	      .if idn <adr>,<#0>
	        clr reg
	      .iff
	        mov'mod adr,reg
	      .endc
	    .endc
	  .endc
	.ENDM

	.MACRO	APIA nam,cod
	  .macro nam,obj,mod
	    mov$ obj,r0,mod
	    emt	 cod
	  .endm
	.ENDM

;	XXDP API

	API	GetLin 0	;
	API	ParFld 1	;
	APIR0	TypMon 2	; TypMon adr
	APIA	TypMsg 3	; TypMsg adr[,A|R]
	APIR0	PutCha 4,B	; PutCha cha
	API	GetTer 5	;
	API	GetCha 6	;
	API	NewLin 7	;
	API	PutTab 10	;
	API	ParOct 11	;
	APIA	OpnFil 12	; OpnFil adr[,A|R]
	API	CloFil 13	;
	API	LoaFil 14	; r0,r1
	API	ReaWrd 15	;
	API	ReaByt 16	;
	APIR0	PutTer 17,B	; PutTer cha
	API	ReaNxt 20	;
	API	ReaBlk 21	;
	APIA	SetAbt 22	; SetAbt adr[,A|R]
	APIR0	JmpAbt 23	; JmpAbt adr
	API	CmpSpc 24	; r0,r2
	API	SpcAsc 25	; r1,r2
	APIA	SetLin 26	; SetLin adr[,A|R]
	API	GetDat 27	;
	API	OctAsc 30	;
	API	GetDev 31	;
	API	RptFld 32	;
	API	LptMod 33	;
	API	TerMod 34	;
	API	LoaSup 35	;
	API	ParDec 36	;
	API	PadTer 37	;
	API	PshBat 40	;
	API	PopBat 41	;
	API	GetCom 42	;
	API	GetSys 43	;
	APIA	TypBrk 44	; TypBrk adr[,A|R]


.sbttl	Monitor macros						(data)

;	MAP$ ensures that the XXDP/XXRT memory map is adhered to and
;	also reports free area sizes at the end of layout segments.

	.MACRO	MAP$ LAB LOC END FRE
	  .if nb <end>
	   end::
	   fre == <loc-1000> - <.-x$xini>
	  .endc
	  .iif gt <.-x$xini>-<loc-1000>,.error ;;lab exceeds loc
	  . = x$xini + <loc-1000>
	  lab::
	.ENDM


;	LIMIT$ checks that code does not exceed memory limits.

	.MACRO LIMIT$ loc
;	  .iif gt <loc-1000>-<.-x$xini>
	  .iif lt <.-x$xini>-<loc-1000>,.error ;;lab exceeds loc
	.ENDM


;	REL$ manages relocated addresses.

	.MACRO	REL$ OFF
	  .if lt inmax.-inidx.
	    .error inmax.-inidx.
	  .iff
	    relavl == inmax.-inidx.
	    inloc. = .
	    . = i$nrel + <inidx.*2>
	    .word  inloc.+off
	    inidx. = inidx.+1
	    .iif ge inidx.-inmax., .error ; too many relocations
	    . = inloc.
	  .endc
	.ENDM

;	MOVR, MOVBR, JMPR, PSHR and .WORDR use relocated address.

	.MACRO	MOVR SRC,DST
	  rel$	off=2
	  mov	src,dst
	.ENDM

	.MACRO	MOVBR SRC,DST
	  rel$	off=2
	  movb	src,dst
	.ENDM

	.MACRO	JMPR LOC
	  rel$	off=2
	  jmp	loc
	.ENDM

;	CALLR is reserved for Call-Return, so use CALLX

	.MACRO	CALLX LOC
	  rel$	off=2
	  call	loc
	.ENDM

	.MACRO	PSHR VAL
	  rel$	off=2
	  psh	val
	.ENDM

	.MACRO	.WORDR VAL
	  rel$	off=0
	  .word	val
	.ENDM

;	MOVA and PSHA implement position-independent addressing.

;	PSHA - Push address

	.MACRO	PSHA ADR
	  mov	pc,-(sp)
	  add	#adr-.,(sp)
	.ENDM

;	PSHB/POPB - Push/Pop byte

	.MACRO	PSHB ADR
	  movb	adr,-(sp)
	.ENDM

	.MACRO	POPB ADR
	  movb	(sp)+,adr
	.ENDM

	.MACRO	ADDA	SRC,DST
	 mova	<SRC>,<DST>,ins=add
	.ENDM

	.MACRO	MOVA	SRC,DST,INS=MOV
	  .ntype ma$typ,DST	;get DST type
	  ma$reg=ma$typ&7	;ma$reg - register
	  ma$mod=ma$typ/8.&7	;ma$mod - mode
				;
	 .IRP	r$,<\ma$reg>	;get the register

	 .if ne ma$reg-7	;register 7 always special
	 .if eq ma$mod-0	;rn
	  INS	pc,DST		;
	  add	#src-.,DST	;
	  .mexit
	 .endc
	 .if eq ma$mod-1	;(rn)
	  INS	pc,(r$)		;
	  add	#src-.,(r$)	;
	  .mexit		;
	 .endc
	 .if eq ma$mod-2	;(rn)+
	  INS	pc,(r$)		;
	  add	#src-.,(r$)+	;
	  .mexit		;
	 .endc
	 .if eq ma$mod-4	;-(rn)
	  INS	pc,-(r$)	;
	  add	#src-.,(r$)	;
	  .mexit		;
	 .endc
	 .endc			;pc
	 ;
	 ; anything else
	 ;
	  mov	pc,-(sp)	;pc dst, @dst
	  add	#src-.,(sp)	;
	  INS	(sp)+,dst	;
	 ;			;
	 .ENDR			;.irp
	.ENDM


.sbttl	Constants						(data)

;	CPU and device vectors

	v$ebus	= 4		; bus error vector
	v$ecpu	= 10		; cpu error vector
	v$eemt	= 30		; emt vector
	v$eltc	= 100		; line clock vector
	v$ekwp	= 104		; kw11p clock vector

;	Hardware registers

	TKS	= 177560	; keyboard CSR
	TKB	= 177562	; keyboard buffer
	TPS	= 177564	; terminal output CSR
	TPB	= 177566	; terminal output buffer
	PSW	= 177776	; PSW 
	 cbit	= 1		; PSW carry bit
	 vbit	= 2		; PSW overflow bit
	LTC	= 177546	; line clock
	KWP	= 172540	; KW11P clock
	LPT	= 177514	; line printer

;	S$YCFG - XXDP hardware config flags

	syLTC$	= 1		; line clock present
	syKWP$	= 2		; programmable clock present
	syLPT$	= 4		; line printer present
	syNUB$	= 10		; NoUniBus
	sy50H$	= 20		; 50 Hertz clock

;	Terminal constants

	bs	= 10		; backspace
	ht	= 11		; tab
	lf	= 12		; line feed
	cr	= 15		; carriage return
	esc	= 33		; escape
	space	= 40		; space
	del	= 177		; delete/rubout

;	Control keys

	ctrlc	= 3		; ^C - cancel activity
	ctrlq	= 21		; ^Q - resume terminal output
	ctrls	= 23		; ^S - pause terminal output
	ctrlu	= 25		; ^U - cancel line
	ctrlx	= 30		; ^X - resume after batch WAIT
	ctrlz	= 32		; ^Z - terminate batch file


.sbttl	Monitor structure					(data)

;	Memory layout
;
;	kw memory  kw image disk pointer label
;	---------  -------- ---- ------- -----
;	28 160000   4 20000      s$ytop: x$xtop:  I/O page
;	   157777     17777	 	 x$xlim:  Address limit
;	   157xxx     17xxx        	 x$xdrv:  Driver
;	27 154000   3 14000              x$xsta:  Static
;	   152000     12000  12  s$yper: x$xper:  Permanent
;	26 150000   2 10000  10  s$ytra: x$xtra:  Transient
;	   146000     06000  06 	 x$xbat:  Batch
;	25 144000   1 04000    		 x$xhgh:  Init high	
;	   141000     01000  01   	 x$xini:  Init and MFD
;	24 140000   0 00000  00  s$yrel: x$xbot:  Boot
;	   137000                s$ysup: x$xsup:  DRS Supervisor

;	Monitor region block numbers

;	moBOO.	= 0		; boot
;	moMFD.	= 1		; MFD block (XXDP only)
	moBAT.	= 6		; batch area block
	moTRA.	= 8.		; transient area block
	moCLI.	= 10.		; cli area block
	moODT.	= 16.		; odt overlay

;	Low memory syscom variables
;
;	I've left these locations as absolute addresses.
;
;	@#40	.byte	= system device unit number
;	@#41	.byte	= LMD - low media code
;	@#42	.word	= batch diagnostic managed exit path
;
;	@#52	.word	job status word
			
	scMAN$ 	= 1	; Manual control flag (SMI/CMI)
;	scXMA$	= 10000	; XM-monitor app (XXDP V2)
;
;	@#176		; SWR - Software switch register
;	@#200		; Default start address
;
;	@#2100		; default DRS diagnostic start address
;			; LoaFil patches @#200 to <jmp @#2100>

;	Command line structure

;	cl.ptr	= 0	; command line base pointer
;	cl.len	= 2	; command line length
	 cllen.	= 44. 	; default command line length
	 clavl.	= 42.	; available characters

; 	Device information block
	
	dv.nam	= 0	;"DL"	; driver name
	dv.uni	= 2	;"0"	; device unit
	dv.med	= 3	;mdDL.	; media code

;	Driver interface

	dr.buf	= -22.	; 752	; buffer pointer
	dr.ent	= -20.	; 754	; directory entry number in segment
	dr.fnm	= -18.	; 756	; rad50 filename
	dr.sbl	= -12.	; 764	; first file block
	dr.opn	= -10.	; 766	; open file function
	dr.rst	= -8.	; 770	; read monitor function
	dr.tra	= -6	; 772	; transfer function
	dr.dev	= -4	; 774	; get device info function
	dr.uni	= -2	; 776	; device unit
	dr.sts	= -1	; 777	; operation status
	dr.csr	=  0	; 000	; CSR address
	io.wct	=  2	; 002	; word count
	io.buf	=  4	; 004	; buffer address
	io.blk	=  6	; 006	; block number
	io.ufd	=  8.	; 012	; (user file) directory start block
	io.spc	=  10.	; 014	; ascii filespec

;	dr.sts - driver status

;	drSUC.	= 0		; an absence of errors
;	drTRA.	= -1		; dr.tra - transfer error
;	drFNF.	= 1		; dr.opn - file not found


.sbttl	RUST/RT data, errors					(rust)
.asect
x$xlow:

;	The RUST/RT-11 initialization section begins here.
;
;	RUST/RT startup data

	.=j$bjsw	; RT-11 job status word
r$tjsw:	.word	jsovr$	; overlay flag keeps image channel open

.psect
x$xini::		; XXRT relocation reference location (1000)

;	RUST/RT host data

rt$res:	jmp	rt$rst	; restore function pointer
r$tdev:	.rad50	/   /	; rad50 "DD "
r$tddu:	.rad50	/   /	; rad50 "DDu"
r$tdua:	.asciz	"   "	; asciz "DDu" 
r$tuni:	.word	0	; device unit
r$t64u:	.byte	0	; 64-unit flag
	.byte	0	; free
r$tcfg:	.word	0	; save XXDP s$ycfg
r$tmon:	.word	0	; save d$pmon
r$tstk:	.word	0	; saved RT-11 stack
r$tret:	.word	0	; save RT$RES to XXRT stack
r$ttop:	.word	0	; memory top
r$tlow:	.word	0	; RUST/RT memory low
r$ttks:	.word	TKS	; rt-11 TKS
r$ttps:	.word	TPS	; rt-11 TPS
r$t50h:	.word	0	; 50 hertz clock
			;
r$temt:	.blkw	5	; RT-11 EMT area
r$tdst:	.blkb	di.bbs	; RT-11 .dstat area
r$tsnd:	.blkb	60.	; send command line
r$ttim:	.blkw	4	; V11 time
			;
r$thst:	.byte	0	; host: boot=-1, rust=0, rt-11=1
r$tv11:	.byte	0	; V11 present
r$tcli:	.byte	0	; single-line command
r$trfs:	.byte	0	; run-from-shell
r$tdsc:	.byte	0	; don't shell xxrt->rt-11 command
r$tmed:	.byte	0	; XXDP media code
r$tchn:	.byte	0	; chain command
r$tmcp:	.byte	0	; mscp fix
	.byte	0
.if ne dbg$c
r$tdbg:	.blkw	6
.endc

;	RUST/SJ image identification

	$imgdef	XXRT 3 0
	$imginf	fun=sav aut=ijh use=<XXDP meets RT-11 XXRT.SAV>
	$imgham	yrs=<2021> oth=<>
;	%date
	$imgdat	<03-Sep-2022 01:22:44>
;	%edit
	$imgedt	<221  >


.sbttl	Error handling 						(rust)

;	RT$ERR - Error messages and exit
;
;	in	r0 ->	message
;		r1 ->	rad50 name
;
;	?XXRT-E-Message [DD:]

	.MACRO	RTERR$ MSG NAM
	 .iif nb <msg>, mov msg,r0
	 .if nb <nam>
	  mov	nam,r1
	 .iff
	  clr	r1
	 .endc
	 call	rt$err
	.ENDM

rt$err:	psh	r0
	.print	#r$sfac		; "?XXRT-E-"
	.print	(sp)+		; message
	beqw	r1,20$		; no device name coming
	mov	(r1),r0		; get the rad50 device name
	mov	#r$sdrn,r2	; r2 -> ascii output
	call	su$unp		; unpack r0 to (r2)
	cmpb	-(r2),#space	; r2 -> past ascii
	beq	10$		; ends with a space ("DD ")?
	inc	r2		; no - keep it
10$:	movb	#':,(r2)+	; "DD:"
	movb	#'],(r2)+	; "DD:]"
	clrb	(r2)		; exterminate
	.print	#r$sdrn		; intimidate
20$:	clr	r0		; pontificate
	.exit			; extricate

;	Messages

r$sfac:	.ascii	"?XXRT-E-"<200>
r$smap:	.asciz	"Extended memory systems not supported"
r$sbig:	.asciz	"System too big to save"
r$ssav:	.asciz	"Error saving monitor"
r$sxxl:	.asciz	"XX: must be loaded for RT commands"

r$sloa:	.ascii	"Driver not loaded ["<200>
r$sdrv:	.ascii	"Device not supported by XXDP ["<200>
r$sldx:	.ascii	"Logical disks not supported ["<200>
r$ssub:	.ascii	"Sub-directories not supported ["<200>
r$sdrn:	.asciz	"    "
	.even


;	MVSTR$ - Move string macro

	.MACRO	MVSTR$ SRC,DST
	 .iif nb <src>,mov src,r0
	 .iif nb <dst>,mov src,r1
	 call	rt$mvs
	.ENDM

rt$mvs:	movb	(r0)+,(r1)+	; move string
	bne	rt$mvs		;
	dec	r1		; for appending
	return


;	Development debug facility
	
	.if ne dbg$c
;	DB$SAV - Save debug vectors

db$sav:	pshs	<r1,r0>
	mov	#v$ebus,r0
	mov	#r$tdbg,r1
	.rept	6
	mov	(r0)+,(r1)+
	.endr
	pops	<r0,r1>
	return

;	DB$RES - Restore debug vectors

db$res:	pshs	<r1,r0>
	mov	#v$ebus,r0
	mov	#r$tdbg,r1
	.rept	6
	mov	(r1)+,(r0)+
	.endr
	pops	<r0,r1>
	return
	.endc


.sbttl	RUST/RT startup engine					(rust)

;	RT$ENG - RUST/RT startup engine
;
;	The order of tests is critical.

start::				; XXRT.SAV starts here
				;
rt$eng:	mov	sp,r$tstk	; save the stack for the exit path
	.settop	#-1		; force kmon out of memory
	mov	r0,r$tlow	; low address of system
				;
	call	rt$hst		; RUST/RT-11/BOOT host determination
	call	rt$v11		; detect V11 PDP-11 emulator
	call	rt$rcv		; receive single-line command, if any
				;
	call	rt$inf		; RT information collection
	call	rt$drv		; select the XXRT system driver
	bcs	10$		; driver error
				;
	call	in$siz		; memory size and hardware configuration

;	Write the RUST/RT monitor and drivers to disk

	call	rt$sav		; save the RT monitor

;	We're ready for diagnostic heaven

	reset			; lights out (clears all interrupts)
	.mtps	#340		; doors locked
				;
;	RUST/RT is history now	;
				;
	jmp	in$eng		; galacto city

10$:	rterr$	#r$sdrv,#r$tdev	; driver error


;	RT$HST - RUST/SJ, RUST/BOOT, RT-11 determination
;
;	Work out whether we're running under RT-11 or RUST/SJ.
;
;	We can't launch XXRT under a memory mapped monitor.
;	(RUST/XM, RUST/RTX, RT-11/XM)

rt$hst:	mov	@#j$bsys,r4	; r4 -> rmon 
				;
	bit	#cnxmm$,rm.cfg(r4); mapped monitor?
	beq	10$		; no - we're single
	rterr$	#r$smap		; mapped monitor error

;	Setup monitor signature
;
;	r$thst	rmon	
;	-1	240	RUST/BOOT (later)
;	 0	137	RUST
;	+1	167	RT-11

10$:	movb	#-1,r$thst	; assume boot
	cmp	(r4),#240	; NOP => RUST/BOOT? (-1)
	beq	20$		; yep
	inc	r$thst		; assume RUST
	cmpb	(r4),#137	; JMP@# => RUST/SJ   (0)
	beq	20$		; yep
	inc	r$thst		; assume RT-11	     (1)
20$:	movb	r$thst,s$yhst	; reflect it
	.if ne dbg$c
	call	db$sav
	.endc
	return


.sbttl	Save RUST/RT monitor to disk				(rust)

;	RT$SAV - Save the RT environment
;
;	The XXRT.SAV image has space for an 8kw system save.
;
;???	Unbuffered save will fail for smallish 16kw systems
;	However, buffering may produce a fractured system image
;
;	o in$siz must be called before rt$sav (to set r$ttop)

	map	sv.mem,,0	; memory address
	map	sv.sav		; the save address
	map	sv.res		; restore address
	map	sv.blk		; image block address
	map	sv.wct		; word count of area
	map	sv.bbs		;

;	.macro	rtsav$	mem,res,cnt
;	  .word	mem, svadr$, res, svblk$, cnt
;	  svadr$ = svadr$ + cnt
;	  svblk$ = svblk$ + <cnt/512.>
;	.endm
;	svadr$ = 20000

.if ne ext$c
;		mem	sav	res	blk	wct
r$tini:	.word	1000,	22000,	1000,	18.,	256.*5
r$tboo:	.word	0,	27000,	6000,	23.,	256.
r$tsys:	.word	0,	30000,	7000,	24.,	256.*4*8.
	svbuf. = 22000
	svsys. = 22000
	svblk. = 18.
.iff
;		mem	sav	res	blk	wct
r$tini:	.word	1000,	20000,	1000,	16.,	256.*5
r$tboo:	.word	0,	25000,	6000,	21.,	256.
r$tsys:	.word	0,	26000,	7000,	22.,	256.*4*8.
	svbuf. = 20000
	svsys. = 20000
	svblk. = 16.
.endc
	svres. = 1000
	svwct. = <256.*4*8.>+<6*256.>
	svbct. = svwct.*2

rt$sav:	bmib	r$thst,50$	; rust/boot
				;
	mov	r$ttop,r0	; top of memory
	sub	r$tlow,r0	; words to save
	cmp	r0,#svbct.	; got enough space
	bhi	50$		; nope - system too big
.if ne map$c
	mov	r$tlow,r$tsys
	asr	r0		; make words
	mov	r0,r$tsys+sv.wct	
.iff
	mov	r$ttop,r$tsys	;
	sub	#svsys.*2,r$tsys;
.endc

	.mtps	#340		; we need a static system image
	mov	#r$tini,r4	; first entry
	mov	#3,r3		; counter
10$:	mov	sv.mem(r4),r0	; source
	mov	sv.sav(r4),r1	; destination
	mov	sv.wct(r4),r2	; count
20$:	mov	(r0)+,(r1)+	; move 'em up cowboy
	sobw	r2,20$		; git along little doggies
	bne	20$		; things are more like they are now..
	add	#sv.bbs,r4	;
	sobw	r3,10$		;
	.mtps	#0		;
40$:	.writw	#r$temt,#15.,#svbuf.,#svwct.,#svblk.
	bcs	60$		; fine
	return

50$:	rterr$	#r$sbig		; system too big
60$:	rterr$	#r$ssav		; error saving system


.sbttl	Restore RUST/RT from disk				(rust)

;	RT$RST - Restore RUST/RT monitor and exit
;
;	The monitor routine MO$RTX reads the saved data back into memory.
;	We just need to copy the data into the right places.

rt$rst:	pop	r3		; r3 -> command code
	pop	r0		; r0 -> cl$eng
	bmib	r$thst,bt$res	; it's RUST/BOOT
	mov	r$tstk,sp	; restore the RT stack
	call	rt$sto		; store return command, if any
				;
	mov	#r$tboo,r4	; 
	mov	#2,r3		; counter
20$:	mov	sv.res(r4),r0	; source
	mov	sv.mem(r4),r1	; destination
	mov	sv.wct(r4),r2	; count
	add	r2,r0		;
	add	r2,r0		;
	add	r2,r1		;
	add	r2,r1		;
30$:	mov	-(r0),-(r1)	; move 'em up cowboy
	sobw	r2,30$		; git along little doggies
				;
	add	#sv.bbs,r4	; next save/restore region
	dec	r3		; any more regions?
	bne	20$		; yep

;	Re-enable the hardware

.if ne mcp$c
	tstb	r$tmcp		; /M mscp fix?
	bne	31$		; yes - don't reset MSCP
.endc
	cmpb	r$tmed,#mdDU.	; DU:?
	bne	31$		; nope
	mov	r0,@#ducsr.	; yes - force MSCP init

31$:;	reset			; 
	mov	#100,@r$ttks	; reenable the keyboard
				;
	bit	#syLTC$,r$tcfg	; got a line clock?
	beq	35$		; no
	bis	#100,@#LTC	; yes - reenable it
	br	40$		; skip programmable clock reenable
				;
35$:	bit	#syKWP$,r$tcfg	; programmable clock?
	beq	40$		; no
	mov	#1,@#k$prpt	; and the repeat count
	mov	#kpLIN$,@#k$pcsr; get the clock going

;	RUST/RT is back in charge

40$:	call	rt$tim		; restore time if under V11
	.hreset			; precautionary
	call	rt$snd		; send command, if any
				;
;	Back to RUST/RT		;
				;
	beqb	r$tchn,50$	; not chain
	.chain			; chain (does not return)

50$:	clr	r0		; de rigueur
	.exit			; exit to where we came from


.sbttl	BT$SAV - Save/Restore RUST/BOOT				(rust)

;	RUST/BOOT code to be added later
;
;	Like XXDP, BOOT can't write, so we can't save to disk.
;	What we can do is reboot BOOT
;	Or copy to VM:
;	Or do nothing

bt$sav:	return

;	r0 ->	cl$eng

bt$res:	jmp	(r0)


.sbttl	Receive RUST/RT command					(rust)

;	RT$RCV - Receive RT CCL single-line command
;
;	.xxrt <some command>

rt$rcv:	bmib	r$thst,50$	; rust/boot
				;
	clr	r0		; cancel shell
	call	rt$she		;
				;
	bleb	j$bcct,#1,50$	; empty lines don't count
	sub	#84.,sp		; space for dummy line
	mov	sp,r1		;
	.gtlin	#0,r1		; eat up command
	add	#84.,sp		; and throw it away
				;
10$:	mov	#j$bcst,r0	; return pointer
	mov	#c$lbuf,r1	;
	mov	j$bcct,r2	; get it again
	clrb	j$bcct		; once only
	clrb	j$bcst(r2)	; terminate string
20$:	blob	(r0),#'a,30$	; we're upper class 
	bhib	(r0),#'z,30$	;
	bicb	#40,(r0)	; and egalitarian
30$:	movb	(r0)+,(r1)+	;  store
	dec	r2		;
	bne	20$		;
				;
	dec	r1		; r1 -> zero terminator
	cmpb	-(r1),#'>	; want stay with XXRT?
	bne	40$		; nope
	cmpb	-(r1),#'<	; really?
	bne	40$		; nope
	clrb	(r1)		;
	incb	r$trfs		; treat as run-from-shell

40$:
.if ne mcp$c
	cmpb	c$lbuf,#'/	; "XXRT/"
	bne	45$		; 
	cmpb	c$lbuf+1,#'M	; "XXRT/M" - MSCP patch
	bne	45$		;
	incb	r$tmcp		; yes - remember that
	br	50$		; and ignore the command line
.endc
45$:	incb	s$ycli		; single line command coming
	incb	r$tcli		; remember it locally
	bneb	r$trfs,50$	; was run-from-shell - don't exit
	bisb	#2,s$ycli	; is single-line
50$:	return


.sbttl	Store and send command to RUST/RT			(rust)

;	RT$STO is called while XXRT is still present in memory
;	(RT$STO calls RT$DCL to massage commands)
;
;	RT$SND is called after RT-11 has been copied back to memory

;	RT$STO - Store RT command line
;
;	RT$STO - store the command before wiping out the XXRT monitor.
;	RT$SND - send the command after restoring RUST/RT

;	r3 ->	XXRT input command field

	rtCOP. = 4
	rtDIR. = 3
	rtHLP. = 2
	rtDCL. = 1
	rtRET. = 0

rt$sto:	bmib	r$thst,20$	; not interesting for RUST/BOOT
	mov	#r$tsnd,r4	; where we store the text
	clrb	(r4)		; assume no command
	beqw	r3,20$		; no command pointer
	beqb	(r3),20$	; no command content
				;
	call	rt$dcl		; massage some commands
	bcc	20$		;
				;
10$:	movb	(r3)+,(r4)+	; "command<>"
	bne	10$		; move it in
	dec	r4		;
	cmpb	-(r4),#'>	; want stay with RT?
	bne	20$		; nope
	cmpb	-(r4),#'<	; really?
	bne	20$		; nope
	clrb	(r4)		; yes - truncate
	incb	r$tdsc		; don't shell command
20$:	return


;	RT$DCL - Massage commands for DCL
;
;	D =>	DCL "DIR
;	H =>	Chain "TT:=SY:XXRT/X[/T]|[topic]"
;
;	r3 ->	XXRT input command field
;	r4 ->	DCL output command

rt$dcl:	pshs	<r3,r2,r1,r0>
	mov	r4,r1		; r1 -> output string
	movb	(r3)+,r2	; r2 = "x"
	beq	50$		; no command at all
	beqb	(r3),10$	; just "x"<enter>
	beqb	(r3),#'/,10$	; some "/qualifier"
	bneb	(r3)+,#space,50$; not "x"<space>".."<enter>

;	r2 = "H" or "D" or not us
;	r3 -> topic or directory path, or nothing
;
;	H(elp)

10$:	bneb	r2,#'H,20$	; not "H"(elp)
	mov	r3,r0		; r3 -> "[topic]"
	incb	r$tchn		; remember it's a chain
	br	30$		; we did it

;	D(ir)

20$:	bneb	r2,#'D,50$	; not D(ir); you do it
	mvstr$	#70$		; "DIR "
	mov	r3,r0		; 

30$:	mvstr$			;
40$:	tst	(pc)+		; we did it
50$:	sec			; you do it
	pops	<r0,r1,r2,r3>	;
	return

70$:	.asciz	"SY:EXPAT DIR "
80$:	.asciz	"SY:EXPAT XXRT "
	.even

;	RT$SND - Send command to RUST/RT
;
;	#RT <some DCL command>

rt$snd:	bmib	r$thst,40$	; RUST/BOOT can't do this

;	If running under RT-11 make sure that XX.SYS is loaded

	mov	@#j$bsys,r0	; point at the monitor
	bnew	(r0),#167,10$	; not RT-11
	mov	#r$tdst,r1	; point to dstat area
	.dstat	r1,#60$		; get XX: device status
	bcs	70$		; not installed
	beqw	di.ent(r1),70$	; not loaded

;	Send chain or DCL command

10$:	mov	#r$tsnd,r0	;
	bneb	r$tchn,20$	; it's a chain command
	beqb	(r0),40$	; no command to send
				;
	mov	#j$bcst,r1	; DCL command
	mvstr$			;
	sub	#r$tsnd,r0	;
	mov	r0,j$bcct	;
	bis	#jsdcc$,j$bjsw	;
	br	30$		;

;	Chain to XXHELP

20$:	mov	#j$bhcs,r1	; help command string
	mvstr$			;
				;
	mov	#50$,r0		;
	mov	#j$bcfn,r1	; 500: .rad50 "sy xxhelpsav"
	mov	(r0)+,(r1)+	;
	mov	(r0)+,(r1)+	;
	mov	(r0)+,(r1)+	;
	mov	(r0)+,(r1)+	;
	bis	#jscha$,j$bjsw	;

;	Setup shell return

30$:	bneb	r$tdsc,40$	; don't shell command
	mov	#1,r0		; RUST shell, RT-11 non-zero trigger
	call	rt$she		; setup the shell
40$:	return
50$:	.rad50	/sy xxhelpsav/	;

60$:	.rad50	/XX /
70$:	rterr$	#r$sxxl


.sbttl	RUST/RT command shell interface				(rust)

;	RT$SHE - Trigger or cancel RUST/RT shell
;
;	RUST/SJ checks for a command shell just before prompting
;	for a keyboard command. All we need to do is copy our 
;	filename, "SY:XXRT.SAV", into the monitor database slot.
;
;	in	r0=0	cancel shell
;		r0=1	trigger shell

rt$she:	bgtb	r$thst,rt$rts	; it's the RT-11 shell
	mov	j$bsys,r1	; locate the rust extended system header
	mov	rm.syn(r1),r1	; rust magic numbers
	mov	-(r1),r1	; r1 -> rust extended header
	add	#eh.she,r1	; r1 -> shell filespec (also shell presence)
	bnew	r0,20$		; trigger, not cancel
	beqw	(r1),10$	; shell was not active
	incb	r$trfs		; remember run-from-shell
10$:	clr	(r1)		; cancel
	br	30$		;
20$:	mov	r$tddu,(r1)+	; .rad50 /ddu/ - device+unit
	mov	#40$,r0		; the filespec
	mov	(r0)+,(r1)+	; copy in the filespec
	mov	(r0)+,(r1)+	;
	mov	(r0)+,(r1)+	;
30$:	return
40$:	.rad50	/xxrt  sav/	;


;	RT$RTS - RT-11 shell
;
;	RT-11 does not have an equivalent RUST/SJ facility. Instead
;	we have to jump through hoops using a driver, XX.SYS.
;
;	When loaded, XX: intercepts EMTs, looking for for a .PRINT
;	EMT followed by either <mov r4,r4> or <mov r5,r5>, which
;	tells us RT-11 is just about to prompt for a keyboard command.
;
;	The EMT intercept mechanism is safe because the RT-11 group
;	used my EMT trace driver, TR:, which uses the same algorithm.
;
;	The .PRINT <mov rx,rx> mechanism is safe because its designed
;	to support the RT-11 single-line editor, SL:.
;
;	mov	sp.pc(sp),r0		;
;	bneb	-2(r0),#emPRI.,10$	; not .print
;	beqw	(r0),#010404,xx$she	; mov r4,r4
;	beqw	(r0),#010505,xx$she	; mov r5,r5
;
;	in	r0=0	cancel shell
;		r0=1	trigger shell

	xx.sta 	= 2		; XX driver interface
	xx.she	= 4		; 1 => trigger shell
	xx.new	= 6		; 1 => elide newline
	xx.cmd	= 10		; 32-byte command string

rt$rts:	call	rt$xxx		; get the driver
	bcs	10$		; not loaded
	beqw	r0,rt$new	; cancel
	mov	#1,xx.she(r1)	; trigger the driver
	add	#xx.cmd,r1	; r1 -> command
	mvstr$	#20$		; "RUN "
	mvstr$	#r$tdua		; "RUN DDU"
	mvstr$	#30$		; "RUN DDU:XXRT"
10$:	return
20$:	.asciz	"RUN "
30$:	.asciz	":XXRT"
	.even


;	RT$NEW - Fudge to handle extra RT-11 newlines
;
;	o Return from an RT-11 shell command adds a extra newline
;	  We compensate by eliding one
;	o An exception occurs when RT-11 returns to XXRT directly
;	  In this case the trigger is still set
;	o This routine also detects recursion

rt$new:	call	rt$xxx		; get the driver
	bcs	30$		; not loaded
	beqw	xx.she(r1),10$	; not return-from-shell
	incb	r$trfs		; run-from-shell
10$:	beqw	xx.new(r1),20$	; not iniated by DCL
	movb	#1,s$ynew	; yes - drop a newline then
20$:	clr	xx.she(r1)	; clear both
	clr	xx.new(r1)	;
30$:	return


;	RT$XXX - RT-11 XX: driver interface
;
;	out	r1 ->	XX: database
;	fail	c=1	driver not loaded

rt$xxx:	psh	r0		;
	mov	#20$,r0		; r0 -> <XX >
	mov	#30$,r1		; r1 -> dstat return area
	.dstat	r1,r0		; get device status
	bcs	10$		; not loaded
	mov	di.ent(r1),r1	; -> driver ha.cqe
	beq	10$		; not loaded
	add	#ha.sio-ha.lqe,r1; r1 -> handler start
	tst	(pc)+		; fine
10$:	sec			; fail
	pop	r0		;
	return			;
20$:	.rad50	/xx /		; xx: driver
30$:	.blkw	4		; xx: dstat info


.sbttl	RUST/RT information					(rust)

;	RT$INF - Get RUST/RT system information

	rtimg. = rm.csw+<15.*ch.bbs> ; image channel csw offset

rt$inf:	mov	@#j$bsys,r4	  ; r4 -> rmon 

;	Check scope or hardcopy

	mov	@#v$eemt,r3	  ; r3 -> 
	bmiw	-(r3),10$	  ; scope - RT-11 magic
	clrb	s$yscp		  ; hardcopy

;	Inherit 50/60 hertz state
				  
10$:	bit	#cn50h$,rm.cfg(r4); 50 hertz clock?
	beq	20$		  ; no
	inc	r$t50h		  ; yes - remember that

;	r0 -> RT-11 image channel block

20$:	mov	r4,r0		  ; r0 -> rmon
	add	#rtimg.,r0	  ; r0 -> image channel

;	Monitor start block

	mov	ch.sbl(r0),d$pmon ; save monitor start block

;	Get the XXRT image device name	

	mov	ch.csw(r0),r1	; get the image csw
				;
	bic	#csin$n,r1	; isolate the device index
	mov	r4,r2		;
	add	rm.pnp(r4),r2	; point to pname table
	add	r1,r2		; r2 -> device permanent name
	mov	(r2),r$tdev	; copy the rad50 /DD / device name

;	RUST/SJ subdirectories not supported

	assume	ci.csw eq 0	  ;
	bpsw	#csSUB$,(r0),60$  ; sub-directories not supported

;	Device Unit

	movb	ch.uni(r0),r1	; device unit
	bic	#^c7,r1		; minus job number
	mov	r1,r$tuni	; device unit
	mov	r1,d$runi	; device unit

;	Device+Unit

	mov	r$tdev,r0	; .rad50 /dd /  
	add	r$tuni,r0	; + octal unit
	add	#36,r0		; .rad50 /  0/
	mov	r0,r$tddu	; .rad50 /DDu/
	mov	#r$tdua,r2	; r2 -> ascii output
	call	su$unp		; unpack r0 to (r2)

;	64-unit support (later)

	bit	#c364u$,rm.cf3(r4) ; 64-unit support?
	beq	30$		; no
	incb	r$t64u		; remember that

;	Host device information

30$:	mov	#r$tddu,r0	; r0 -> <XX >
	mov	#r$tdst,r1	; r1 -> dstat return area
	.dstat	r1,r0		; get device status
	bcs	40$		; not installed (impossible)
	beqw	di.ent(r1),40$	; not loaded

;	May not be LD:

	assume	di.dsw eq 0	;
	beqb	(r1),#deldc.,50$; logical disk
	return

40$:	rterr$	#r$sloa,#r$tdev	; driver not loaded
50$:	rterr$	#r$sldx,#r$tdev	; logical disks not supported
60$:	rterr$	#r$ssub,#r$tdev	; sub-directories not supported


.sbttl	Reset RT time under V11					(rust)

;	RT$TIM - Reset RT date/time if V11 emulator running
;
;	The V11 PDP-11 emulator has an API that allows us to get the
;	Windows host system time. This works for both RUST and RT-11.
;
;	.macro	vrapi$ cod, arg
;	 .iif nb <cod>, mov cod,r1
;	 .iif nb <arg>, mov arg,r0
;	 clc		; C=0
;	 abcb	pc	; trigger V11 API
;	.endm

rt$tim:	beqb	r$tv11,30$		; no V11
					;
	vrapi$	#vrHTZ.,#0		; call V11 API
	mov	@#j$bsys,r1		; r1 -> rmon
	bic	#cn50h$,rm.cfg(r1)	; assume 60
	beqw	r0,#60.,10$		; it is 60 hertz
	bis	#cn50h$,rm.cfg(r1)	; my bad - it's fifty
					;
10$:	vrapi$	#vrTIM.,#r$ttim		; get time block from V11
	psh	r0			; time block pointer
	psh	#emstx$			; EMT code/subcode for .STIMX
	mov	sp,r0			; r0 -> EMT 375 area
	emt	375			; .SDTTM with RUST era extension.
	cmp	(sp)+,(sp)+		; dump emt area
30$:	return


;	RT$V11 - Detect V11 emulator
;
;	.macro	vrdet$
;	 clc
;	 sbcb	pc
;	;c=1 => is V11
;	;c=0 => not V11
;	.endm

rt$v11:	clrb	r$tv11			;
	vrdet$				; detect V11
	adcb	r$tv11			; c=1 => V11 present
	return				;


.sbttl	Memory size and hardware configuration			(init)

;	IN$SIZ - Size memory
;
;	out	r0/r1	burnt
;
;	Setup s$ykwd, s$ypgs, s$ytop, s$ycfg and s$yemu

in$siz:	call	in$cap		; capture bus/cpu traps
				;
	clr	r0		; start at zero
10$:	mov	(r0),(r0)	; test location read/write
	bvs	20$		; trap catcher says no
	tst	(r0)+		; skip it 
	bit	#3777,r0	; reached a 1kw boundary?
	bne	10$		; no
				;
	inc	s$ykwd		; increment kiloword count
	add	#32.,s$ypgs	; and mmu page count
	cmp	r0,#160000	; max size reached?
	bne	10$		; nope
				;
20$:	mov	r0,s$ytop	; yes - up total kernel memory
	mov	r0,r$ttop	; needed for RUST/RT restore
       ;dec	s$ypgs		; sic] s$ypgs: starts .word -1
	fall	in$cfg
	
;	IN$CFG - Hardware configuration
;
;	PSW/UNIBUS check

in$cfg:	mov	@#j$bsys,r0	; r0 -> rmon
	bit	#c2bus$,rm.cf2(r0) ; Qbus flag set in RT-11 config2?
	beq	20$		; no - unibus (or Pro)
	bis	#syNUB$,s$ycfg	; no unibus
				;
;	50 hertz check

20$:	tst	r$t50h		; 50 hertz time zone?
	beq	30$		; nope - other side of the pond
	mov	#50.,s$yltk	; setup LTC line clock tick counters
	mov	#50.,s$yktk	; setup KWP programmable clock counters
	bis	#sy50H$,s$ycfg	; flag 50hz present
				
;	KW11P, line clock, line printer detection

30$:	tst	@#KWP		; KW11P
	bvs	40$		; not a programmable clock
	mov	h$wkwp,s$ykwp	;
	bis	#syKWP$,s$ycfg	; KWP$ flag
				;
40$:	tst	@#LTC		; line clock
	bvs	50$		; no LTC
	mov	h$wltc,s$yltc	;
	bis	#syLTC$,s$ycfg	; LTC$ flag
				;
50$:	tst	@#LPT		; test line printer
	bvs	60$		; no LPT
	mov	#LPT,s$ylpt	; line printer
	bis	#syLPT$,s$ycfg	; LPT$ flag

60$:	mov	s$ycfg,r$tcfg	; we need it for RUST/RT restore
	fall	in$sim	

;	IN$SIM - Detect SimH PDP-11 simulator

in$sim:	movb	r$tv11,s$yemu	; set and check V11 emulator
	bne	20$		; is V11, not SimH
;	bnew	b$trom,40$	; rom means not emulator
	mov	#m$msr0,r0	; emulator check
	mov	#m$msr1,r1	;
	tst	(r1)		; got MMU with SR1 etc?
	bvs	10$		; nope
	clr	(r0)+		; clear SR0 with increment
	bis	#160000,-(r0)	; overwrite and freeze
	bneb	(r1),#170027,10$; SIMH magic number is (17)0027
	dec	s$yemu		; remember it's SimH
10$:	clr	(r0)		; make them all clean again
	clr	(r1)		;
20$:	fall	in$can
	fall	in$can		; restore traps and return

;	Catch/Restore bus/cpu traps

	.enabl	lsb
in$can:	psh	r0		;
	.trpset	#r$temt,#0	; cancel traps
	br	10$		;
in$cap:	psh	r0		;
	.trpset	#r$temt,#in$trp	; capture bus/cpu traps
10$:	pop	r0		;
	return
	.dsabl	lsb

;	Bus/Cpu trap ISR

	stack	pc,ps
in$trp:	call	in$cap		; recapture traps
	bis	#vbit,sp.ps(sp)	; return PSW vbit set
	rti			; back past trapped instruction


.sbttl	XXDP init engine					(init)

;	IN$ENG - Initialization engine
;
;	Beginning of the reverse-assembled XXDP+ code base.
;
;	The XXRT/XXDP environment takes over at this point.

xx$ini:
in$eng:	mov	#s$ystk,sp	; stack

	.if ne dbg$c		;
	call	@#db$res	; restore debugger
	.endc			;

;	Setup low memory trap catchers
;
;	000000:	.word	2
;	000002:	.word	0
;	000004:	.word	6
;	000006:	.word	0
;	...	...	...
;
;	o Older diagnostics completely overwrite low memory, wiping
;	  out trap catchers in the process. V2 DRS resets the trap	
;	  catchers.
;
;	o The EXERT TRAPS command rebuilds the trap catchers.

	clr	r3		; r3=0
10$:	tst	(r3)+		; r3=2
	mov	r3,-2(r3)	;	0: .word 2
	clr	(r3)+		; r3=4	2: .word 0
	bnew	r3,#1000,10$	;

;	Setup pointers to key monitor areas

	mov	s$ytop,r0	; top of memory (aka 160000)
	mov	r0,s$yrel	; 160000 20000	 
	sub	#20000,s$yrel	; 140000 00000 relocation constant
	mov	r0,s$ytra	;   		
	sub	#10000,s$ytra	; 150000 10000 transient area
	mov	r0,s$yper	;  		
	sub	#6000,s$yper	; 152000 12000 permanent area
	mov	r0,s$ysup	;
	sub	#37000,s$ysup	; 121000       supervisor load address

;	Setup device name, unit & CSR

	mova	d$riob,r5	; IOB
	call	@dr.dev(r5)	; get ye device name "DD"
	mov	r0,s$ydev	; s$ydev -> d$pdev: .ascii "DDu"<med>
	add	s$yrel,s$ydev	;
	movb	d$runi,s$yuni	; s$yuni
	mov	d$rcsr,s$ycsr	; s$ycsr

;	Checksum the transient .5k area 

	mov	#x$xtra,r2	; from 10000 to 12000
20$:	add	(r2)+,s$y5ck	; aka s$ytra to s$yper
	cmp	r2,#x$xper	; done?
	bne	20$		; not bloodly likely

;	Relocate the MOVR/JMPR/PSHR/.WORDR list

	mov	s$yrel,r3	; r3 = relocation constant
	mov	#i$nrel,r2	; r2 -> relocation list
30$:	tst	(r2)		; end of table?
	bmi	40$		; yup
	add	r3,@(r2)+	; relocate another brother
	br	30$		; more

;	Copy up monitor and jump to high copy

40$:	mov	s$ytop,r0	;
	mov	#20000,r1	; top of low memory monitor
50$:	mov	-(r1),-(r0)	; copy monitor up
	cmp	r1,#xx$jmp	; reached the start of the monitor?
	bhi	50$		; nope

;	r0 ->	xx$jmp in high memory

	jmp	(r0)		; transfer to copied xx$jmp

;	Launch XXDP/XXRT monitor

xx$jmp:	jmp	xx$sta		; time to clock on


;	I$NREL - Relocation list
;
;	This table is filled in by MOVR and .WORDR macros.
;
;	i$nrel:	.word	addr
;		...
;		.word	-1

	inidx. = 0		; current table index
	inmax. = 100.		; maximum index
i$nrel:	.rept	inmax.+1	; create table
	.word	-1		; fill with -1
	.endr			;


.sbttl	Batch engine				    (overlay)	(batch)
map$	x$xbat 6000 iniend inifre
	
;	The XXRT monitor code starts here.
;
;	The Batch overlay starts here.
;
;	ba$xxx		Batch functions
;	bc$xxx		Batch commands
;	bu$xxx		Batch utilities
;
;	b$axxx		Batch data
;	b$sxxx		Batch strings
;
;	The batch area is copied to the overlay region for execution.
;	Because of this all relative addresses that access the monitor
;	outside its overlay area need to be offset, along with the
;	the batch command dispatch table entries. "$$" is that offset.

	$$ = o$vreg-b$areg	; offset for relative mode relocation


;	BA$ENG - Batch engine
;
;	o The first instruction of the batch region (b$areg) and CLI
;	  region (c$lreg), act as signatures (b$asig/c$lsig) used to 
;	  to determine which overlay is currently loaded.

b$areg:
b$asig:	basig. = 010667		;\batch signature (must be first location)
ba$eng:	mov	sp,b$astk-$$	;/save the batch stack
	clr	f$isck-$$	; invalidate batch file checksum
	fall	ba$cmd		; to force a reread

;	BA$CMD - Batch command loop
;
;	XXRT resets the default command line for before GetLin below.
;	XXDP does this only for the CLI command loop. Because of this
;	XXDP Batch uses the DRS command line buffer after DRS exits.

ba$cmd:	mov	b$astk-$$,sp	; reset the stack		(added)
	SetAbt	ba$abt,A	; generic batch command abort
	.if ne bat$c
	tstb	b$acon-$$	; maintenance console mode?
	beq	10$		; nope
	NewLin			;
	PutCha	#'@		; issue prompt "@"
	.endc			;
10$:	SetLin	#0		; get default command line back	(added)
	GetLin			; get something
	 bcc	ba$exi		; end of chain file
	fall	ba$dis		; dispatch command

;	BA$DIS - Dispatch batch command
;
;	r0/r1 are carefully preserved by the dispatcher. They are used
;	(redundantly) by the batch END command.
;
;	XXDP's command search algorithm crashes the system for	(added)
;	commands that consist of only a command field terminator.
;	XXRT ignores leading spaces and reports "?Batch fail" for
;	other terminator-only commands.
;
;	r0 ->	command field
;	r1 =	terminator

ba$dis:	ParFld			; get a command name
	 nop			; ignore errors
				;
	tstb	(r0)		; empty line?
	beq	70$		; yes
	cmpb	(r0),#';	; comment?
	beq	70$		; yes
	cmpb	r1,#':		; label: ?
	beq	70$		; yes
	cmpb	(r0),#space	; space at start of line?	(added)
	beq	ba$dis		; yes - ignore that
	cmpb	(r0),#ht	; tab at start of line		(added)
	beq	ba$dis		; yes - ignore that too
	cmpb	r1,(r0)		; terminator only?		(added)
	beq	ba$err		; yes - that would crash

;	Lookup command name
;
;	r0 ->	field (static)
;	r1 =	terminator
;	r2 ->	b$aloo
;	r3 ->	field (loop)
;	r4 ->	b$adis 

	mova	b$aloo,r2	; r2 -> lookup table
	mova	b$adis,r4	; r4 -> dispatch table
10$:	mov	r0,r3		; r0/r3 -> field
	br	30$		; skip terminator test first time
				;
20$:	cmpb	r1,-1(r3)	; hit terminator?
	beq	40$		; yes
30$:	cmpb	(r3)+,(r2)+	; skip until we do
	beq	20$		;
40$:	tstb	-(r2)		; end of lookup table entry?
	bne	50$		; no - do the next
	tstb	-(r3)		; also the end of the field?
	beq	60$		; yes - we have a command
	cmpb	(r3),#space	; space is also field end
	beq	60$		; we have a command
				; not a match
50$:	tstb	(r2)+		; skip remainder of name
	bne	50$		;
	tst	(r4)+		; more lookup entries to come?
	bne	10$		; yep
	br	ba$err		; nope - "?Batch error" and abort

;	Call batch command
;
;	r0 ->	command field
;	r1 =	terminator

60$:	add	(r4),r4		; r4 -> dispatch entry
				;
	call	(r4)		; call command
				;
	call	mo$rst-$$ 	; restore monitor and PR7
70$:	br	ba$cmd		; get another command


;	Batch QUIT command
;
;	Return to prior batch file or CLI.

ba$exi:				; ba$cmd EOF ept
bc$qit:	mov	b$astk-$$,sp	; restore caller's tack context
	return			; return to CLI or other batch file


;	BA$ABT - Batch abort
;
;	Abort routine (from set abort above).
;
;	o XXDP+ doesn't abort chain files for syntax errors. XXRT does.

ba$err:	clr	r0		; ?Batch fail
ba$abt:	clrb	s$yqui-$$	; turn off quiet mode
	psh	r0		; save and test for message
	beq	10$		; no message - abort (no need to pop)
	TypMon			; say what's troubling us	(added)
10$:	jmp	mo$bab-$$	; abort batch completely	(added)


;	Batch strings

b$sthn:	.ascii	"THEN"		; no trailing zero required
b$send:	.ascii	"END"<377>	; non-zero terminator required (ba$fal)
	.even

;	Batch lookup table

b$aloo:	.asciz	"SMI"		; Set Manual Intervention
	.asciz	"CMI"		; Clear Manual Intervention
	.asciz	"L"		; Load diagnostic
	.asciz	"S"		; Start diagnostic
	.asciz	"RT"		; Return to RUST/RT		(added)
	.asciz	"R"		; Run utility or diagnostic
	.asciz	"C"		; Chain to nested batch file
	.asciz	"GOTO"		; Goto label
	.asciz	"WAIT"		; Wait for ctrl-x or ctrl-c
	.asciz	"QUIET"		; Don't display batch file commands etc
	.asciz	"PRINT"		; Display a message
	.asciz	"END"		; for IF..THEN..END
	.asciz	"QUIT"		; Quit batch file 
	.asciz	"IFLMD"		; IF Low Media code
	.asciz	"IFERR"		; IF Error
	.asciz	"IF"		; IF/switch and IF ^C
	.asciz	"ODT"		; Debugger
	.even

;	Batch dispatch table

	.MACRO	BAT$ ADR
	 .word	adr-.
	.ENDM

b$adis:	BAT$	bc$smi  	; SMI
	BAT$	bc$cmi  	; CMI
	BAT$	bc$loa  	; Load
	BAT$	bc$sta  	; Start
	BAT$	mo$rtx-$$	; RT
	BAT$	bc$run  	; Run
	BAT$	bc$chn  	; Chain
	BAT$	bc$gto  	; Goto 
	BAT$	bc$wai  	; Wait
	BAT$	bc$qui  	; Quiet
	BAT$	bc$prt  	; Print
	BAT$	bc$end  	; End
	BAT$	bc$qit  	; Quit
	BAT$	bc$ilm  	; Iflmd 
	BAT$	bc$ier  	; Iferr
	BAT$	bc$ift  	; If
	BAT$	bc$odt		; ODT
	.word	0


.sbttl	Batch Chain Run Load Start CMI SMI SWR ODT  (overlay)	(batch)

;	Batch CHAIN command
;
;	Chains recursively to another batch file.
;
;	C filnam.typ
;
;	o The batch chain command must have an explicit file type.
;
;	o The batch chain command does not accept switches.
;
;	o Batch supports one level of chain nesting. XXDP+	(added)
;	  does not check for additional nesting. XXRT does.

bc$chn:	cmpb	s$ybat-$$,#2	; too many chain levels?	(added)
	bhis	ba$err		; yes - abort
				;
	ParFld			; get a filespec
bu$erj:	 br	ba$err		; fail

;	Invoke the batch engine recursively

	PshBat			; up chain level and open batch file
	psh	b$astk-$$	; save the current batch stack
				;
	call	ba$eng		; call the batch engine recursively
				;
	pop	b$astk-$$	; restore our stack
	PopBat			; pop nest chain file, return to prior
	return			;


;	Batch RUN command
;
;	Activates a diagnostic or utility.
;
;	R filnam[/pass][ start][ ; comment]
;
;	o CC$RUN has a description of the filename parsing strategy.

bc$run:	ParFld			; get a filespec
	 br	bu$erj		; filename error
				;
	psh	r0		; save field 
	call	bu$sta		; get a start address and/or repeat count	
	pop	c$lnxt-$$	; restore filename field
	call	bu$loa		; load image
	br	bu$act		; activate


;	Batch LOAD file command
;
;	Loads, but does not initiate a diagnostic or utility.
;
;	L filespec
;
;	o CC$RUN has a description of the filename parsing strategy.

bc$loa:				; LOAD EPT
bu$loa:	ParFld			; get "FILNAM"
	 br	bu$erj		; invalid filename
				;
	mov	r0,r4		; get field start
10$:	cmpb	(r4)+,r1	; hunt for terminator in r1
	bne	10$		; until end of string
	movb	#'.,-1(r4)	; replace with "."
	movb	#'B,(r4)+	; add "BIC"
	movb	#'I,(r4)+	;
.if ne brn$c		
	movb	#'?,(r4)+
.iff
	movb	#'C,(r4)+	;
.endc
	clrb	(r4)		; terminate string
       ;add	#4,c$lnxt-$$	; add four to the line end pointer
				; sic] c$lnxt has no practical use here
				; r0 -> filespec
	clr	r1		; r1 = base address
	LoaFil			; load image
	return


;	BU$STA - Batch start utility
;
;	Get batch Run/Start start address and/or repeat count.
;
;	in	r1 =	command field terminator
;
;	S 200		start at 200
;	S/5		repeat five times
;	S/5 200		start 200, repeat five times
;
;	o XXDP silently rejects odd addresses; XXRT complains.	(added)

	.enabl	lsb
bu$sta:	mov	#1,r0		; r0 = 1 - s$yrpt default
	mov	r0,s$ysta-$$	; default start address flag = 1
				;
	cmp	r1,#'/		; /passes?
	bne	10$		; nope
	ParDec			; translate decimal count
bu$er2:	 br	bu$erj		; oops
10$:	mov	r0,s$yrpt-$$	; set the repeat count (#1 or explicit)
				;
	ParOct			; get the octal start address
	 br	20$		; no such luck
	bit	#1,r0		; odd address?
	bne	bu$er2		; we're not all LSI's you know	(added)
	mov	r0,s$ysta-$$	; start/load address
20$:	return
	.dsabl	lsb


;	Batch START command
;
;	Starts a program read into memory by a Load command.

;	S[/repeat] [address]
;
;	o See CLI Start (CC$STA) for comments.

bc$sta:	call	bu$sta		; get the start address
	fall	bu$act		; activate


;	BU$ACT - Batch Start/Run program common

	assume	s$yact-s$ysta eq 2
bu$act:	mova	s$ysta-$$,r0	; r0->sta
	cmp	#1,(r0)		; cmp act,#1 - #1 => diagnostic
	beq	10$		; is diagnostic
	mov	(r0)+,(r0)	; mov sta,act
	br	20$		; has explicit start address
10$:	cmp	(r0)+,(r0)	; cmp #1,act - explict start address?
	bne	20$		; yes - use that
	mov	#200,(r0)	; mov #200,act - use standard start address

;	Configure low-memory syscom

20$:	mov	#42,r0		; r0 -> @#42
	mova	bu$ret,(r0)	; 42 - diagnostic return path
				;
	movb	d$runi-$$,-(r0)	; 41 - device unit
	movb	d$pmed-$$,-(r0)	; 40 - device media code
	cmp	-(r0),-(r0)	; 34 - skip two words
	mov	s$yemt+2-$$,-(r0);32 - saved EMT vector + 2
	mov	s$yemt-$$,-(r0)	; 30 - saved/overwritten EMT vector
				;
	mov	sp,b$ustk-$$	; save stack
	clr	@#TKB		; initialize for ctrl-c/ctrl-z
				;
;	Activate batch program	;
				;
	call	@s$yact-$$	; call ye app
				;
;	Batch image exit	; also invoked by LoaSup DRS exit
				;
bu$exi:	mov	b$ustk-$$,sp	; restore stack
	clr	r0		; r0=0 status
	callr	em$rst-$$ 	; rebuild emt vector and psw


;	BU$RET - Batch managed image exit return
;
;	BU$RET has two cases:
;
;	42=0	Utility exit 
;	42!=0	Diagnostic exit
;
;	SYSMAC apps return here via @#42 with the protocol below:
;
;	.=42	.word	bu$ret	; filled in by bu$act above
;	.=46	.word	$endad	; diagnostic sets this location
;
;	endpas:	mov	@#42,r0	; get monitor address
;		beq	$doagn	; branch if no monitor
;		reset		; clear the world
;	$endad:	call	(r0)	; goto monitor (or loop forever)
;		nop		; save room
;		nop		; for
;		nop		;  act11
;	$doagn:	jmp	@(pc)+	; return
;	$rtnad:	.word	rstart	; 
;
;	Later SYSMAC diagnostics may have the following:
;
;	endpas:	mov	@#42,r0	; get monitor address
;		beq		; branch if no monitor
;		nop		;
;	$endad:	call	(r0)	; call co-routine
;		...		;
;	
;	ZDZAG0.BIC has the old protocol, ZDZAG1.BIC has the new form.
;	In fact, ZDZAG1 seems to be identical to ZDZAG0 except for this
;	code segment. Probably issued as a field service patch.
;
;	Other diagnostics have only @#42=$endad and <call (r0)>.
;
;	RUN/PASS end-of-pass control keys (from XXDPXM):
;
;	ctrl-c	Terminate diagnostic, set "^C" condition	(added) 
;	ctrl-z	Terminate  batch stream, return to CLI		(added)
;
;	o BU$RET resets PR7 either at BU$EXI or via return path.

bu$ret:	dec	s$yrpt-$$	; all iterations done (usually just one)
	beq	bu$exi		; yes - reset PR7 and exit image
	.if ne ret$c		; redundant XXDP code?
	tst	@#42		; diagnostic or utility?
	beq	bu$exi		; utility - exit image
	.endc			;
	tst	s$yqvs-$$	; /QV quick verify switch?
	bne	bu$exi		; yes - exit image

;	Handle ctrl-z and ctrl-c

	cmpb	@#TKB,#ctrlz	; ctrl-z?			(added)
	bne	10$		; no - check ctrl-c
	mova	t$ectz-$$,r0	;
	jmp	mo$bab-$$	; batch abort
				;
10$:	cmpb	@#TKB,#ctrlc	; ctrl-c?			(added)
	beq	bu$exi		; yes - exit image
	fall	bu$pr7		; do another pass resetting PR7

;	BU$PR7 - Set PR7

bu$pr7:	callr	em$pr7-$$	; reset PSW to PR7 and return


;	Batch CMI (Clear Manual Intervention) command
;
;	CMI

bc$cmi:	bic	#scMAN$,@#52	; CMI - Clear manual
	return


;	Batch SMI (Set Manual Intervention) command
;
;	SMI

bc$smi:	bis	#scMAN$,@#52	; SMI - Set manual
	return


;	Batch ODT command					(added)
;
;	ODT [address][=value][/]
;
;	Examines and modifies memory.

	$O = o$dreg-b$areg	; offset for relative mode relocation
bc$odt:	cmp	b$asig-$$,#odsig. ; is ODT resident?
	beq	10$		; yes
	mov	#moODT.,r2	; ODT overlay block
	mova	x$xbat-$$,r3	; r3 = -> 12000/152000
	call	mo$rea-$$	; read the overlay
10$:	jmp	od$odt-$O-$$


.sbttl	Batch Goto If/Err/LMD Wait Print Quiet 	    (overlay)	(batch)

;	Batch GOTO command
;
;	Transfers control to a specified label.
;
;	label:
;	...
;	GOTO label<enter>
;   or: GOTO label/...
;	...
;	label:
;
;
;	o GOTO search labels must terminate with newline or "/". The
;	  "/" termination is not documented and remains unexplained.
;
;	o An V2 documentation example has the search label terminated
;	  with ":", but that will fail.
;
;	o Label statements must be the only statement on a command
;	  line.  Anything following the colon (:) is ignored, allowing
;	  comments to be added.
;
;	  label: ; some comment
;
;	o Batch first searches forward through the file. If that 
;	  fails batch rewinds to the beginning of the file and 
;	  searches forward again.
;
;	  XXDP+ loops forever if a label is not found. XXRT	(added) 
;	  detects and reports missing labels.
;
;	o XXDP stores the target label in the s$ygto buffer and	(added)
;	  then reads candidate lines into the system command line
;	  buffer. Because of this we can't display the <GOTO XXX>
;	  command if the label is not found (because that command
;	  has been overwritten).
;
;	  XXRT leaves the GOTO command in the system line buffer (added)
;	  and creates a temporary buffer at the end of the batch
;	  overlay, allowing failed GOTO commands to be reported.

bc$gto:	ParFld			; parse the goto label
bu$er3:	 br	bu$er2		; wrong - just return
	decb	s$yqui-$$	; mute output while searching
				;
	mov	r0,r2		; r2 -> target
10$:	cmpb	(r0)+,r1	; copy field to buffer
	bne	10$		; not at terminator
	clrb	-(r0)		; zero the end of the buffer string
				;
	mova	b$alin-$$,c$llin-$$; use b$alin for GetLin 	(added)
				;
	clr	r3		; detect missing labels		(added)		

;	Search loop

20$:	GetLin			; search forward for the label
	bcs	30$		; got a good line
				; EOF
	com	r3		; first time?
	beq	bu$er3		; nope - not found - abort  	(added)				;
				;
	clr	f$ipos-$$	; hit EOF - rewind batch file
	clr	f$isck-$$	; clear saved checksum to force read
       ;br	20$		; ParFld fails back to 20$ for us
				;
;	r2/r4->	target label from GOTO command
;	r0 ->	candidate label:
;	r1 =	":"

30$:	ParFld			; get the first field on the line
	 br	20$		; no field - get another line
				;
	cmpb	r1,#':		; LABEL: ?
	bne	20$		; not a label - get next line
				
;	Label compare

	mov	r2,r4		; r4 -> target label
40$:	cmpb	(r0)+,(r4)+	; r0 -> candidate label
	beq	40$		; still fits
				;
	cmpb	-(r0),r1	; did candidate end with ":"?
	bne	20$		; no
	cmpb	-(r4),#'/	; did target end with "/"?
	beq	50$		; that's okay for some unknown reason
	tstb	(r4)		; did target hit end of line?
	bne	20$		; no - try the next chain file line

;	Label found

50$:	incb	s$yqui-$$	; put that back how we found it
go$ret:	return			; we are located at the label


;	Batch IF command
;
;	Searches the CLI chain switch list for a match. See CC$CHN.
;
;	IF <switch> THEN
;	...
;	END
;
;	o "THEN" must be on the same line as "IF".
;
;	o XXDPXM adds support for <IF ^C THEN>. So does XXRT,(added)
;	  however, XXRT checks the TKB directly rather than 
;	  via the switch list.

bc$ift:	movb	r1,r3		;
	ParFld			; r0 -> condition switch
	 br	bu$err		; IF without a condition error

;	Check "^C" condition

	cmpb	(r0),#'^	; "^"?				(added)
	bne	10$		;
	cmpb	1(r0),#'C	; "^C"?
	bne	10$		;
	cmpb	@#TKB,#ctrlc	; seen ctrl-c?
	br	bu$ctc		; eq=>true, ne=>false

;	Check /switch conditions
;
;	r0 ->	target switch

10$:	mova	s$yswi-$$,r2	; the switch buffer
20$:	movb	(r2),r1		; end of switches?
	beq	bu$fal		; yes - fail
	cmpb	(r2)+,#'/	; "/"
	bne	20$		; must be found
	mov	r0,r4		; r4 -> candidate
30$:	cmpb	(r4)+,(r2)+	; r2 -> stored 
	beq	30$		; compare until missmatch
	cmpb	-(r2),#'/	; terminated by "/"
	beq	40$		; yes (multiple switches)
	tstb	(r2)+		; EOL? (pop back past terminator)
	bne	20$		; no - start over
40$:	fall	bu$tru		; handle true condition


;	BU$TRU - Condition true utility
;
;	For a true condition we need to parse our way past the
;	THEN token.
;
;	IFx <true condition> THEN
;	...
;	END
;
;	o B$STHN actually points to "THENEND".
;
;	o Anything following THEN is ignored.

bu$tru:	ParFld			; get yet another field
	 br	bu$err		; bummer
				;
	mova	b$sthn,r2	; THEN
10$:	cmpb	(r0)+,(r2)+	; shall I compare thee?
	beq	10$		; to a summer's "THENEND"
	tstb	-(r0)		; did we complete?
	beq	go$ret		; yep - return
bu$err:	jmp	ba$err


;	Batch IFLMD (If Low Media) command
;
;	Compares a specified code with the current device media code.
;
;	IFLMD <media code> THEN
;	...
;	END
;
;	o The media codes are listed in XXDRV.MAC.

bc$ilm:	ParOct			; get the media code
	 br	bu$err		; error
 	cmpb	r0,d$pmed-$$	; match?
bu$ctc:	beq	bu$tru		; true (if ^C ept)
	br	bu$fal		; false


;	Batch IFERR (If Error) command
;
;	Check if app has set s$yerr to signal an error condition.
;
;	IFERR THEN
;	...
;	END

bc$ier:	tst	s$yerr-$$	; has a program reported an error?
	bne	bu$tru		; true - yes
	fall	bu$fal		; false


;	BU$FAL - Condition false utility
;
;	For false conditions we search for the next END statement.
;
;	IF <false-condition> [THEN]
;	...
;	END
;
;	o The algorithm requires that "END" be the only content on a line.
;
;	o Nested <IF><...><END> constructions are not supported.

bu$fal: mova	b$alin-$$,c$llin-$$; use b$alin for GetLin input(added)
	GetLin			; search chain file for "END"
	bcc	bu$err		; infinite IF universe sans END
				;
	mova	b$send,r2	; r2 -> "END"
10$:	cmpb	(r0)+,(r2)+	; compare strings
	beq	10$		; while they match
	tstb	-(r0)		; source completed?
	bne	bu$fal		; no - keep searching
				; found - return
bc$end:	return			; dummy batch end command


;	Batch WAIT command
;
;	Pauses batch file execution until ctrl-x is input.
;
;	WAIT
;	...
;	ctrl-x	- use ctrl-x to continue
;	ctrl-c	- use ctrl-c to abort the diagnostic
;
;	o Ctrl-c aborts XXRT and all XXDP monitors here.
;
;	o XM exits WAIT with <enter> as well as ctrl-x.
;
;	o V1 and V2 do not echo ctrl-x. XM specifically
;	  inhibits ctrl-x echo. XXRT echoes ctrl-x.
;
;	o Nothing is displayed in quiet mode.

bc$wai:	GetTer			; wait for operator ^X
	clrb	s$ypnd-$$	; no pending character
				;
	call	te$ctc-$$	; check ctrl-c (aborts batch if so)
	cmpb	r0,#ctrlx	; ctrl-x?
	bne	bc$wai		; nope - spin loop
	call	te$ctx-$$	; echo ctrl-x			(added)
	br	bu$new		; display newline and return


;	Batch PRINT command
;
;	Displays a specified message at the user terminal.
;
;	PRINT some-message...
;
;	o GetLin converts all text to upper case.

bc$prt:	ParFld			; parse anything into the field
	 br	10$		; nothing - so just newline
	TypBrk			; r0 -> display message 
10$:	fall	bu$new		; add newline


;	BU$NEW - Display newline utility

bu$new:	TypBrk	t$enew-$$,A	; display message
	return


;	Batch QUIET command
;
;	Flips QUIET mode.
;
;	QUIET

bc$qui:	comb	s$yqui-$$	; flip the quiet flop
	return


.sbttl	gap					    (gap)	(CLI)

;	The Batch overlay ends here.
;	The gap area starts here.

	batlen. == .-b$areg	; length of batch overlay
map$	x$xgap <6000+batlen.> bovend batfre

	.word	-1		; getlin buffer stopper
b$alin:	.blkb	cllen.		; substitute command line

.sbttl	PutCha PutTer				    (transient)	(API)

;	The gap area ends here
;	The transient area starts here.
;
;	The 512. word transient region is restored by MO$RST if
;	corrupted by a diagnostic.

map$	x$xtra 10000 gapend gapfre


;	TE$PUT - Display a single character
;
;	in	r0 =	character
;
;	out	r0 =	character

te$put:	tstb	@s$ytps		; TPS ready?
	bpl	te$put		; not yet - spin loop
	movb	r0,@s$ytpb	; out damned spot
	return		


;	PutCha - Put Character and check for ctrl-c service	(EMT 4)
;
;	Displays a specified character.
;
;	in	r0 =	character
;	
;		PutCha
;	
;	out	r0 =	available character or zero (from PutTer)
;	abort	ctrl-c

PutCha:	PutTer			; output char and check keyboard
	fall	te$ctc		; check ctrl-c


;	TE$CTC - Check ctrl-c
;	
;	in	r0 =	character to check
;
;	out	true	display "^C" and abort
;		false	return

	.enabl	lsb
te$ctc:	cmpb	r0,#ctrlc	; ^C - are you looking at me?
	bne	20$		; no  - return
	fall	te$ctl		; yes - display and abort


;	TE$CTL - Display control key
;
;	in	r0 =	character
;	
;		call	te$ctl
;	c=0	bcc	displayed
;	c=1	bcs	not displayed
;	
;	out	r0 =	character (whether true or false)
;		"^x"	if control key and not null,tab,^Q,^S
;
;	abort	"^C"	if ctrl-c
;
;	o TE$CTL called by GetLin. TE$CTX from BC$WAI.
;
;	o GetLin filters out CR and LF before calling te$ctl.

te$ctl:	tstb	r0		; ^@ - null
	beq	10$		;
	cmpb	r0,#ctrlz 	; ^Z - above ctrl-z
	bhi	10$		; 
	cmpb	r0,#ht	  	; ^I - tab
	beq	10$		;
				;
te$ctx:	clrb	s$ypnd		; bc$wai entry point
				;
	cmpb	r0,#ctrlc	; ctrl-c?
	beq	30$		; use abort to display "^C".
				;
	psh	r0		; save character
	PutCha	#'^		; out damned spot 
	mov	(sp),r0		; control code
	bis	#100,r0		; make an ascii letter
	PutCha			; "^X"
	pop	r0		; get the code back
				;
	tst	(pc)+		; c=0 - displayed
10$:	sec			; c=1 - not displayed
20$:	return			;
				;
30$:	JmpAbt	#t$ectc		; display "^C" and abort
	.dsabl	lsb


;	PutTer - Put terminal character service			(EMT 17)
;
;	in 	r0	output character
;
;		PutTer
;
;	out	r0	available input character or zero
;
;	o LF should clear s$ycol, the column location. XXDP 	(added)
;	  V1/V2 both increment s$ycol after clearing s$ycol for 
;	  LF causing in incorrect tab positioning. XXRT fixes this.
;
;	o XXDPSM adds code to avoiding echoing Batch WAIT ctrl-x.

PutTer: cmpb	r0,#lf		; linefeed?
	bne	10$		; nope
	clrb	s$ycol		; column zero
	br	30$		; don't increment s$ycol for LF	(added)
10$:	cmpb	r0,#ht		; tab?
	bne	20$		; nope
	call	PutTab		; go tab
	br	40$		;
20$:	incb	s$ycol		; up column count
30$:	call	te$put		; out to TPS
40$:	GetTer			; returns available character
	return


.sbttl	GetLin ParFld RptFld SetLin		    (transient)	(API)

;	GetLin - Get Command Line service			(EMT 0)
;
;	Inputs a terminal or batch file command line.
;
;		GetLin 
;		bcc	EOF	; batch EOF
;	
;	out	r0 ->	command line
;		r0=0	Batch EOF
;		r0->0	empty line
;		r1	unmodified
;
;		c$lnxt->command line
;	
;	abort	"I/O error"	; batch file read error
;
;	o GetLin restores the batch file and position if needed.
;	  PopBat triggers a buffer restore to return to a prior
;	  batch file.
;
;	o XXDP GetLin returns a nonsense command line if EOF is	(added)
;	  detected in Batch mode. Most apps ignore GetLin EOF 
;	  resulting garbage-in-garbage out. XXRT returns a null
;	  line.
;
;	o XXDP DRS loops forever at its prompt for Batch EOF. 	(added)
;	  XXRT ctrl-z aborts Batch GetLin calls.

	.enabl	lsb
GetLin:	tstb	s$ybat		; batch active?
	beq	20$		; nope
				; 
;	Check batch abort

	cmpb	@#TKB,#ctrlz	; ctrl-z abort?			(added)
	beq	100$		; yes - all over

;	Check batch context	;
				;
	mova	d$riob,r5	; r5 -> system device block
	call	rb$chk		; checksum the file block
	cmp	r4,f$isck	; has f$irck changed behind our backs?
	beq	20$		; nope - pristine
				;
;	Restore batch context	;
				;
	OpnFil	b$afnm,A	; open sesame
	mov	f$ipos,r4	; current file position
				;
10$:	dec	r4		; advance to the current file location
	bmi	20$		; one byte at a time
	ReaByt			; errors abort
	br	10$		; 

;	Common CLI/batch stream
;
;	r0	character
;	r1	unmodified
;	r2	buffer pointer
;	r3	buffer count for limit check
;	r4	working copy of character
;	r5	IOB

;	Reset line buffer

20$:	clr	r3		; ctrl/u comes back to here
	mov	c$llin,r2	; r2 -> line
	mov	r2,c$lnxt	; r2 -> first/next field

;	Get next character and filter

30$:	clrb	(r2)		; ensure EOF line is terminated	(added)
	GetCha			; get another character
	bcc	pf$ret		; Batch EOF - return
				;
	movb	r0,r4		; got anything?
	beq	30$		; nulls are ignored
				;
	cmpb	r4,#lf		; linefeed
	beq	70$		;
	cmpb	r4,#cr		; carriage return
	beq	80$		;
	call	te$ctl		; control character?
	bcc	70$		; yes - te$ctl displayed it
				;  and it terminates the line
	cmpb	r4,#del		; backspace?
	beq	60$		; yes

;	Echo

	tstb	s$yqui		; quietly?
	bmi	40$		; yes
	PutCha			; echo character

;	Uppercase

40$:	cmpb	r4,#'a		; lowercase?
	bcs	50$		; nope
	cmpb	r4,#'z		; really lowercase?
	bhi	50$		; nope
	sub	#40,r4		; make it uppercase

;	Store

50$:	cmp	r3,c$llen	; at end of buffer?
	bge	30$		; yes - ignore it
	inc	r3		; nope - advance
	movb	r4,(r2)+	; and store
	br	30$		; and get another

;	Backspace

60$:	dec	r3		; backspace
	bmi	20$		; too far - restart line
				;
	movb	-(r2),r0	; get erased character
	tstb	s$yscp		; VT scope mode?		(added)
	beq	65$		; no - echo it
	TypMon	#t$erub		; video eraze escape sequence
	br	30$		; get next 
65$:	PutCha			; echo erazed character
	br	30$		; eat more

;	End of line
;
;	70$:	"text"<lf><0>	if line ends with LF
;	70$:	"text<ctrl><0>	if line ends with a control key
;	80$:	"text"<0>	if line ends with CR

70$:	movb	r4,(r2)+	; line ends with lf or control key
80$:	clrb	(r2)+		; line ends with cr
	NewLin			; display newline
				;
	cmpb	r4,#ctrlu	; delete line?
	beq	20$		; yes - start over

;	In batch mode:
;
;	o Gobble the lf that follows cr
;	o Save the read block checksum at each line end

	tstb	s$ybat		; in batch mode?
	beq	90$		; no
	inc	f$ipos		; yes - skip the lf position
	ReaByt			; and gobble the lf byte
	mov	f$irck,f$isck	; save the block checksum

;	Return
;
;	out	r0 ->	line buffer
;		r1	unmodified
				
90$:	mov	c$llin,r0	; fine - r0 -> start of line
gl$sec:	jmp	rb$sec		; set EMT cbit and return
100$:	mov	#t$ectz,r0	; 
	jmp	ba$abt+$$	; ctrl-z <^Z>|"?Batch fail"
	.dsabl	lsb


;	ParFld - Parse Field service				(EMT 1)
;
;	Advances to the next field of a command line.
;
;		ParFld
;	fail	 br	EOL	; end-of-line reached
;	  or	 nop		; @r0 and r1 undefined
;	
;	fine	r0 ->	field line segment
;		r0 ->0	EOL
;		r1 =	field terminator
;		r1=0/lf	last field

ParFld:	mov	c$lnxt,r0	; current line position
	tstb	-1(r0)		; past EOL?
	beq	pf$ret		; yes
				;
10$:	movb	(r0)+,r1	; next line character
	beq	40$		; are no more
				;
	mova	t$eter,r3	; terminator list
30$:	cmpb	r1,(r3)+	; this a terminator?
	beq	40$		; yes
	tstb	(r3)		; got more to come?
	bne	30$		; yes
	br	10$		; no - look at next character

;	Good return 

40$:	mov	c$lnxt,c$lfld	; save field starting point
	mov	r0,c$lnxt	; setup new field
	mov	c$lfld,r0	;
				; pf$skp used by ParOct
pf$skp:	add	#2,(sp)		; skip for good return
pf$ret:	return			; pf$ret used by GetLin


;	Terminal strings

t$eter:	.asciz	" /:-=<"<ht>	; terminator list
t$erub:	.byte	bs,space,bs,0	; rubout string
t$ectc:	.asciz	"^C"<cr><lf>	; ^C<cr><lf>
t$ectz:	.ascii	"^Z"		;\^C
t$enew:	.byte	cr,lf,0		;/  <cr><lf> (PutNew and bu$new)
	.even


;	RptFld Repeat command field service			(EMT 32)
;
;	Repeats the current command line field.
;
;		RptFld
;
;	out	c$lnxt = c$lfld

RptFld:	mov	c$lfld,c$lnxt	; next field is current field
	return


;	SetLin - Set command line service			(EMT 26)
;
;	in	r0	= buffer address
;		r1	= buffer length
;		r0=0	=> use defaults (c$lbuf, cllen.)
;
;		SetLin
;
;	out	r0	= effective buffer address
;		r1	= effective buffer length
;
;	o Command line length is not checked.

;	cl.ptr	= 0		; command line pointer offset
;	cl.len	= 2		; command line length offset
;	 cllen.	= 44. 	;^o54	; command line length
;	 clavl.	= 42.	;^o52	; available characters

SetLin:	tst	r0		; default?
	bne	10$		; no - explicit
	mova	c$lbuf,r0	; (called by cc$run)
	mov	#cllen.,r1	; 44. byte command line
				;
10$:	mov	r0,c$llin	; line pointer
	sub	#2,r1		; length - 2 for termination
	mov	r1,c$llen	; store available length
	mov	r0,c$lnxt	; next is current
	return			; used by OctAsc


.sbttl	NewLin TypMon TypMsg TypBrk PutTab 	    (transient)	(API)

;	NewLin - NewLine service				(EMT 7)
;
;	Displays a newline at the user terminal.
;
;		NewLin
;
;	out	r0	burnt

NewLin:	mov	#t$enew,r0	; r0  -> newline string
	fall	TypMon		; display relocated


;	TypMon - Type monitor message service			(EMT 2)
;
;	Relocates and displays a specified message.
;
;	in	r0 -> 	unrelocated zero terminated message
;
;		TypMon
;
;	out	r0	burnt

TypMon:	add	s$yrel,r0	; relocate monitor string
	fall	TypMsg		; and display the message


;	TypMsg - Type message service				(EMT 3)
;	TypBrk - Type Breakthrough message service		(EMT 44)
;	
;	o TypMsg does not display a message in quiet mode
;	o TypBrk unconditionally displays a message
;
;	in	r0 ->	zero-terminated message
;
;		TypMsg
;	     or	TypBrk
;
;	out	r0	burnt unless in quiet mode

	.enabl	lsb
TypMsg:	tstb	s$yqui		; are we quiet?
	bmi	20$		; yes - ignore this
TypBrk:	mov	r0,r2		; make a pointer
10$:	movb	(r2)+,r0	; another
	beq	20$		; done
	PutCha			; out it goes
	br	10$		; more


;	PutTab service						(EMT 10)
;
;	Advances to the next 8-column tab stop.
;
;		PutTab
;
;	out	r0	burnt
;
;	o See 

PutTab:	PutCha	#space		; output a space
	bitb	#7,s$ycol	; check the column
	bne	PutTab		; more columns, more columns
20$:	return
	.dsabl	lsb


.sbttl	GetCha GetTer ParOct OctAsc SpcAsc ParDec   (transient)	(API)

;	GetCha - Get character, check ctrl-c			(EMT 6)
;
;	Inputs a character from the keyboard or batch file.
;
;		GetCha
;	fail 	bcc	EOF	; batch EOF only	
;	
;	fine	r0 =	char
;		s$ypnd	pending character zeroed
;
;	abort	"?I/O error"	; batch file read error

GetCha:	tstb	s$ybat		; batch?
	beq	10$		; nope
				; batch
	ReaByt			; get yet another
	bcc	gt$ret		; fail - EOF - return
	inc	f$ipos		; count it
	br	gl$sc2		; fine - return
				; keyboard
10$:	movb	s$ypnd,r0	; got pending input character?
	bne	30$		; yes - use that
				;
;	Keyboard spin loop	;
				; r0=0
20$:	GetTer			; get available
	tst	r0		; got nothing
	beq	20$		; loop until we do (spin loop)
				;
	call	te$ctc		; check ctrl-c
30$:	clrb	s$ypnd		; pend no more 
gl$sc2:	br	gl$sec		; fine - set carry and return


; 	GetTer - Get available character service		(EMT 5)
;
;	Inputs a character from the keyboad.
;
;		GetTer
;
;	fine	r0	character
;		r0=0	no character available
;		s$ypnd	character as pending
;
;	o GetTer is usually followed by GetCha to gobble up the
;	  pending character.
;
;	o Cursor arrow sequences are of the form <esc><char>
;	  or <esc><[><char> where <char> is any code.
;
;	  For XXDP, cursor arrow keystrokes move the cursor	(added)
;	  around. XXRT filters cursor keystrokes. This works
;	  except for XTECO which uses <escape> as command
;	  terminator. The workaround inhibits filtering for
;	  XTECO by recognizing its unique usage of SetLin.
;
;	o XXDP did not initialize the output value, thus the	(added)
;	  <bpl 60$> returned a random value rather than the 
;	  advertised zero.

GetTer:	clr	-(sp)		; initialize result		(added)
	tstb	@#TKS		; are we relevant?
	bpl	60$		; apparently not (c=0)
	clr	r0		; r2 eq => not waiting for ctrl-q
10$:	mov	r0,r2		; r2 ne => waiting for ctrl-q
				;
20$:	tstb	@#TKS		; who is waiting for us?
	bpl	20$		; nobody
	movb	@#TKB,r0	; the good old TKB
	bic	#^c177,r0	; 7 bits only

;	Ignore cursor arrow escape sequences			(added)

	cmp	c$llin,s$ysup	; system or DRS command line?
	blo	40$		; no - don't filter XTECO escapes
	cmpb	r0,#esc		; escape?
	bne	40$		; no
30$:	GetTer			; get another
	tstb	r0		; got anything?
	beq	30$		; nope - wait
	cmpb	r0,#'[		; skip 133 
	beq	30$		; wait for one
	br	20$		; get next keystroke

;	Handle ctrl-s/ctrl-q
				;
40$:	cmpb	r0,#ctrlq	; ^Q - continue output
	beq	50$		; yes - we continue
	cmpb	r0,#ctrls	; ^S?
	beq	10$		; yes - wait for ctrl-q
	movb	r0,(sp)		; save anything else
	tstb	r2		; seen ctrl-s?
	bne	20$		; yes - wait for ctrl-q

;	Return character

50$:	movb	(sp),s$ypnd	; pending input character
60$:	movb	(sp)+,r0	; return character or zero it in r0
gt$ret:	return


;	ParOct - Parse octal service				(EMT 11)
;
;	Parses an octal number in the command line.
;
;	in	field 	octal string (e.g. "12345")
;	
;		ParFld		; ParFld parse sets up the terminator
;		ParOct
;		bcc	fail
;	
;	fine	r0 =	octal value (e.g. <12345>)
;		r1 =	terminator (lf is alternate terminator)
;
;	fail	r0/r1	burnt
;
;	o A null field is returned as zero.
;
;	o Fail does not distinquish between EOL and syntax errors.
;
;	o XXDP does not return the field terminator except when	(added)
;	  its LF. XXRT does.
;
;	r0	result value
;	r1	terminator
;	r2 ->	field
;	r3	digit
;	r4	octal=000007, decimal=100000+9.

ParOct:	ParFld			; r0 -> field
	 br	gt$ret		; end-of-line - return
	mov	r0,r2		; r1 -> string
	clr	r0		; r0 = result octal
	clr	r4		; r4 = counts digits
				; digit loop:
10$:	movb	(r2)+,r3	; r3 = next character
	cmpb	r3,r1		; is this the terminator?
	beq	20$		; yes
	cmpb	r3,#lf		; special LF terminator?
	bne	30$		; no
	mov	r3,r1		; make LF the terminator
20$:	tst	r4		; got any digits?
	bne	gl$sc2		; yes - success
       ;br	gt$ret		; no - test below fails for LF
30$:bpt
	sub	#'0,r3		; de-ascii
	cmp	r3,#7		;
	bgt	gt$ret
;	bit	#^c7,r3		; out of octal digit range	(added)
;	bne	gt$ret		; yes - fail return
				;
	asl	r0		; multiply accumulator by eight
	asl	r0		;
	asl	r0		;
	add	r3,r0		; and add us in
	inc	r4		; remember we got digits
	br	10$		;


;	OctAsc - Octal to Ascii service				(EMT 30)
;
;	Converts an octal value to a 6-byte ascii string.
;
;	in	r0 =	value
;		r1 ->	output buffer
;
;		OctAsc
;
;	out	r0	burnt 
;		r1 ->	past last (sixth) digit
;
;	o Strings are zero-filled (e.g. value=1 => string="000001").

OctAsc:	mov	#6,r4		; r4 = counter
	clrb	(r1)		; (r1) = result digit
10$:	asl	r0		; rotate
	rolb	(r1)		;
	bisb	#'0,(r1)+	; make it ascii
	dec	r4		; all digits done?
	beq	su$ret		; yes - we're done - return
	clrb	(r1)		; (r1) = result digit
	asl	r0		; rotate once
	rolb	(r1)		;
	asl	r0		; rotate twice
	rolb	(r1)		; 
	br	10$		; go rotate thrice


;	SpcAsc - Convert rad50 spec to ascii service		(EMT 25)
;
;	in	r1 ->	.rad50	/filnamtyp/
;		r2 ->	.ascii	/filnam.typ/
;
;		SpcAsc
;
;	out	r0/r1	burnt

SpcAsc:	call	10$		; "fil"
	call	10$		; "filnam"
	movb	#'.,(r2)+	; "filnam."
10$:	mov	(r1)+,r0	; "filnam.typ"
	fall	su$unp		; unpack


;	SU$UNP - Convert Rad50 to Ascii utility
;
;	in	r0 =	rad50 word to translate
;		r2 ->	output ascii (no zero byte terminator)
;
;	out	r0	burnt
;	 	r2 ->	past ascii 
;		r3/r4	burnt	
;
;	o Invalid characters are cheerfully converted to nonsense.
;
;	o Called only by SpcAsc.

	.enabl	lsb
su$unp:	mova	70$,r4		; rad50 divisors
10$:	clr	r3		; result integer
20$:	cmp	(r4),r0		; got another subtraction?
	bhi	30$		; nope
	sub	(r4),r0		; subtract
	inc	r3		; and count
	br	20$		; 
30$:	tst	r3		; nulls are spaces
	beq	40$		; (14+9+9=32)
	cmpb	r3,#27.		; a rad50 dollar sign?
	bgt	50$		; digit
	beq	60$		; dollar: 27:27 (27+9=36='$')
	add	#32.,r3		; alphabet 1:26 (1+32+14+9+9=65="A")
40$:	add	#14.,r3		; space
50$:	add	#9.,r3		; digits  30:39 (30+9+9=48='0')
60$:	add	#9.,r3		; $
	movb	r3,(r2)+	; store the byte
	tst	-(r4)		; end of list?
	bne	10$		; nope
su$ret:	return

	.word	0, 1, 50	; reverse order
70$:	.word	3100		; rad50 divisors (1600.,40.,1,0)
	.dsabl	lsb


;	ParDec - Parse decimal service				(EMT 36)
;
;	Parses a decimal number from the current command line field.
;
;	in	command line field
;
;		ParDec
;	fail	 br	error	; invalid string
;
;	fine	r0 =	decimal number
;
;	o Fail does not distinquish between end-of-line and syntax errors.

ParDec:	ParFld			; isolate the field
	 br	30$		; errors have a fail return
	clr	r2		; clear result
10$:	movb	(r0)+,r3	; next digit
	cmpb	r3,r1		; is this the terminator (in r1)?
	beq	20$		; yes
	sub	#'0,r3		; de-ascii it
	blt	30$		; below the digit range
	cmp	r3,#9.		; above the range?
	bgt	30$		; yes
	asl	r2		; r2 * 2
	add	r2,r3		; save r2 * 2
	asl	r2		; r2 * 4
	asl	r2		; r2 * 8
	add	r3,r2		; plus r2*2 = r2 * 10
	br	10$		; try for another
20$:	mov	r2,r0		; result to r0
	add	#2,(sp)		; fine skip
30$:	return			; fail return


.sbttl	SetAbt JmpAbt GetDat GetDev GetCom GetSys   (transient)	(API)

;	SetAbt - Set abort address service			(EMT 22)
;
;	Stores a pointer to an abort service routine.
;
;	in	r0 ->	abort function
;
;		SetAbt
;
;	out	s$yabt->abort function

SetAbt:	mov	r0,s$yabt	; save address
	return


;	JmpAbt - Jump to abort routine service			(EMT 23)
;
;	Passes control to the abort service routine.
;
;	in	r0 ->	(unrelocated)abort message
;		r0=0	no message
;
;		JmpAbt
;
;	o The abort routine relocates monitor messages.

JmpAbt:	jmp	@s$yabt		; jump to abort


;	GetDat - Get date service				(EMT 27)
;
;	Returns the system date.
;
;		GetDat
;
;	out	r0	system date
;
;	o The XXDP+ date range is 1-Jan-70 to 31-Dec-99.
;
;	o XXDP did not receive a Y2K date fix.
;
;	o The XXRT date is fixed at 31-Dec-99.

GetDat:	mov	s$ydat,r0	; 1970-1999
	return			; <return> chain


;	GetDev - Get device information service			(EMT 31)
;
;	Returns a pointer to the system device information block.
;
;		GetDev
;
;	out	r0 ->	device info block
;
;	dv.nam	= 0		;.ascii	"DL"	; driver name
;	dv.uni	= 2		;.byte	"0"	; device unit
;	dv.med	= 3		;.byte	mdDL.	; media code

GetDev:	mov	s$ydev,r0	; r0 -> "DD"
	return


;	GetCom - Get communication area address service		(EMT 42)
;
;	Returns a pointer to s$ycom.
;
;		GetCom
;
;	out	r0 ->	s$ycom

GetCom:	mova	s$ycom,r0	; point to s$ycom
	return


;	GetSys - Get System area address service		(EMT 42)
;
;	Returns a pointer to s$ysys.
;
;		GetSys
;
;	out	r0 ->	s$ysys
;
;	o GetSys was added by V2, reusing the EMT code previously
;	  assigned to GetDrv. XXRT does the same.

GetSys:	mova	s$ysys,r0	; point to s$ysys		(added)
	return


.sbttl	Lpt/TerMod LoaSup Psh/PopBat CmpSpc    	    (transient)	(API)

;	LptMod - Output to printer service			(EMT 33)
;
;	Terminal output is sent to the line printer (if present).
;
;		LptMod

	.enabl	lsb
LptMod:	mov	s$ylpt,r2	; got a printer or something else?
	beq	20$		; nope
	br	10$		; fill in csr/buffer addresses


;	TerMod - Output to terminal service			(EMT 34)
;
;	Terminal output is sent to the terminal.
;
;		TerMod
;
;	o Errors and aborts cancel LptMod and return to TerMod

TerMod:	mov	#TPS,r2		; TPS
10$:	mov	r2,s$ytps	; csr
	tst	(r2)+		;
	mov	r2,s$ytpb	; buffer
20$:	return
	.dsabl	lsb


;	LoaSup - Load supervisor service			(EMT 35)
;	
;	Loads DRS.BIN, the XXRT DRS Diagnostic Runtime Supervisor.
;
;		LoaSup
;
;	out	Control is passed to DRS.
;
;	o CLI and Batch have separate activation paths.
;
;	o DRS.BIN must be present on the XXRT system device.
;

LoaSup:	mova	20$,r0		; r0 -> "HSAA??.SYS"
	mov	s$ysup,r1	; r1 -> location
	LoaFil			; read it in
	clr	s$yerr		; clear app error flag
				;
;	Batch-mode activation	;
				;
	tstb	s$ybat		; in batch mode?
	beq	10$		; nope
	call	@s$yact		; Batch supervisor activation
	jmp	bu$exi+$$	; HMDLD0 return via bu$exi
				;
;	CLI-mode activation	;
				;
10$:	call	cu$act		; CLI supervisor activation
	br	cl$eng		; supervisor exit to CLI engine
				;
20$:	.asciz	"DRS.BIN"	; supervisor file spec		(added)
	.even


;	PopBat - Pop batch chain file service			(EMT 40)
;
;	Restores prior chain file or CLI context.
;
;		PopBat
;
;	out	r0/r1 preserved


;	PshBat - Push batch chain file service			(EMT 41)
;
;	Pushes a new chain file onto the chain file stack.
;
;	in	r0 ->	"filnam" field
;		r1 =	field terminator
;
;		PshBat
;
;	out	r0 ->	end of copied "filnam" string
;		r1 =	terminator
;
;	local	1(sp)	ne => Pop, eq => Psh
;		0(sp)	copy counter
;
;	o The chain file stack holds maximum two entries.

PopBat:	psh	(pc)+		;\1(sp)!=0 => PopBat
PshBat:	clr	-(sp)		;/1(sp)==0 => PshBat
	clr	f$isck		; invalidate batch saved checksum
				; (forces GetLin to reread the batch file)
				;
	mova	b$afnm,r2	; current file spec
	mov	r2,r4		; r4 -> ditto
				;
	mova	b$asfn,r3	; saved file name
				;
	tst	(sp)		; pushing or popping?
	beq	10$		; pushing
	psh	r3		; popping - reverse the pointers
	mov	r2,r3		; r2 -> r3
	pop	r2		; r3 -> (sp)-> r2

;	Copy loop

10$:	movb	#10.,(sp)	; 0(sp) = filespec counter
20$:	movb	(r2)+,(r3)+	; copy
	decb	(sp)		; count
	bne	20$		; more
				; 0(sp) = 0
	tst	(sp)+		; 1(sp) = pop/push flag
	bne	40$		; 1(sp) ne => PopBat

;	PshBat coda		

30$:	movb	(r0)+,(r4)+	; copy in new filename
	cmpb	(r0),r1		; r1 = gtfld terminator
	bne	30$		;
	clrb	(r4)		; terminate string
				;
	mov	f$ipos,f$isvp	; save current batch level position
	clr	f$ipos		; clear forces GetLin to open new file
	mov	r4,r0		; r0 -> end of "filnam"
	incb	s$ybat		; => GetLin opens/reads the chain file 
	br	50$		; return

;	PopBat coda
;
;	Decrement the batch "stack" and restore the prior file position.
;	GetLin does all the rest of the work.

40$:	decb	s$ybat		; decrement batch file stack
	mov	f$isvp,f$ipos	; restore prior file position
50$:	return


;	CmpSpc - Compare file specs service			(EMT 24)
;
;	Compares two formatted file specs.
;
;	in	r0 ->	wildcard spec  (e.g. "filnam.bi?")
;		r2 ->	candidate spec (e.g. "mydiag.bic" or ".bin")
;
;		CmpSpc
;	fail	 br	fail
;	fine	...
;
;	out	r0	burnt
;
;	File specs are of the form: "nnnnnn.ttt". For example, the file
;	file spec "a.a" has the form "A_____.A__" where "_" represents the
;	space character. File specs are always converted to upper case.

CmpSpc:	mov	#10.,r4		; size
10$:	cmpb	#'?,(r0)	; "?"?
	beq	20$		; skip
	cmpb	#'%,(r0)	; "%"?
	beq	20$		; skip
	cmpb	(r0),(r2)	; same?
	bne	cs$ret		; nope
20$:	cmpb	(r0)+,(r2)+	; skip
	dec	r4		; more?
	bne	10$		; more
cs$skp:	add	#2,(sp)		; fine
cs$ret:	return			; fail
.sbttl	CLI Engine				    (overlay)	(CLI)
map$	x$xper 12000 traend trafre

;	CLI (Command Line Interpreter)
;
;	The CLI overlay starts here.
;
;	cl$xxx		CLI engine routines
;	cc$xxx		CLI command routines
;	cu$xxx		CLI utility routines
;
;	c$lxxx		CLI data
;	c$sxxx		CLI strings

;	XXDP+ rereads the CLI overlay directly to the overlay area.
;	Since all XXDP+ disk I/O is in multiples of complete blocks 
;	this results in the area 12000:14000 being read, which
;	exceeds the CLI overlay by a few hundred bytes.
;
;	XXRT instead first reads the CLI overlay into the batch area
;	and then copies it to the overlay region, thus affecting only
;	the CLI overlay code itself, allowing us to use MOVR earlier.

o$vreg:				; overlay region
c$lreg:				; CLI region

;	CL$BAB - Batch abort routine
;
;	Batch aborts transfer control to the CLI overlay. We must
;	make sure any subsequent abort come to the CLI abort routine.

c$lsig:	clsig. = 012700		;\CLI signature 
cl$bab: mov	#c$sbab,r0	;/"?Batch fail"			(added)
	.if ne bat$c
	tstb	b$acon		; batch console mode?		(added)
	beq	cl$abt		; nope
	call	cl$err		; yes - display error
	mov	b$astk,sp	; get the batch stack back
	jmp	cc$bat		; and go back to batch
	.endc
	fall	cl$abt		; abort

;	CL$ABT - CLI abort routine

cl$abt:	call	cl$zap		; clean up
	call	cl$err		; display message, if any
	fall	cl$agn		; command loop (again)


;	CL$ENG - CLI engine and system start
;
;	xx$ini .. xx$jmp -> xx$sta	startup path
;	xx$res -> xx$rst -> xx$sta	restart path
;
;	See XX$INI for the system startup path.
;	See XX$RST for the system restart path.

cl$agn:	bneb	s$ycli,cu$rty	; command repeat comes here
				;
xx$sta:				; XXRT startup/restart
cl$eng:	mova	s$ystk,sp	; restore stack
	fall	cl$cmd		;

;	CLI engine command loop
;
;	Image exit path and CLI command engine

cl$cmd:	call	cl$zap		; cleanup environment
	SetLin	#0		; r0/r1 as for GetLin
				;
	asrb	s$ycli		; RUST/RT CLI command?		(added)
	bcs	cl$dis		; yes
	asrb	s$ynew		; supress newline?
	bcs	10$		; yep (RT-11 special)
	NewLin			; nope
				;
10$:	PutCha	#'#		; display XXRT prompt (#)	(added)
				;
	GetLin			; get a command line
	fall	cl$dis		; your command is our wish


;	CL$DIS - CLI command dispatch
;
;	Lookup a command string and dispatch command.
;
;	o XXRT ignores leading spaces. XXDP treats leading	(added)
;	  control codes as errors.

;	r0 ->	field
;	r1 =	field terminator
;	r2 ->	lookup table
;	r3 ->	field copy
;	r4 ->	dispatch table
;	r5 =	(*) seen flag

cl$dis:	ParFld			; get a command name
	 nop			; test below suffices
	tstb	(r0)		; got a command?
	beq	cl$agn		; not this time - go again
	cmpb	(r0),#space 	; space or control key?		(added)
	beq	cl$dis		; skip leading spaces
	blt	cu$inv		; control keys are invalid	(added)
				;
	mova	c$lloo,r2	; r2 -> command table
	mova	c$ldis,r4	; r4 -> dispatch table 

;	Command lookup loop

10$:	mov	r0,r3		; r0/r3 -> command name field
	.if ne abr$c
	clr	r5		; no abrreviation seen yet
	.endc
	br	30$		; skip initial terminator test
20$:	cmpb	r1,-1(r3)	; just passed the terminator (in r1)?
	beq	40$		; yes
30$:	.if ne abr$c
	cmpb	(r2),#'*	; found minimal abbreviation?
	bne	35$		; no
	cmpb	(r5)+,(r2)+	; ++r1=>(*) seen; ++r2=>skip (*)
				;
35$:	cmpb	(r3)+,(r2)+	; same?
	beq	20$		; when you're on a good thing...
				;
40$:	tstb	-(r3)		; matched to end of input?
	beq	45$		; yes - got a command
	cmpb	(r3),#space	; space?
	beq	45$		; yes
	cmpb	(r3),#'/	; a switch?
	bne	50$		; no 
45$:	tst	r5		; seen abbreviation?
	bne	cl$cal		; yes
	tstb	-1(r2)		; end of command entry?
	beq	cl$cal		; yes
	.iff
	cmpb	(r3)+,(r2)+	; same?
	beq	20$		; when you're on a good thing...
40$:	tstb	-1(r2)		; end of the command entry?
	bne	50$		; no - not a match
	tstb	-(r3)		; matched to end of input?
	beq	cl$cal		; yes - got a command - dispatch it
	cmpb	(r3),#space	; space?
	beq	cl$cal		; yes - that's a match too
	cmpb	(r3),#'/	; a switch?
	beq	cl$cal		; yes - likewise good
	.endc
				;
50$:	tstb	(r2)+		; didn't match this entry
	bne	50$		; skip to the end of this entry
	tst	(r4)+		; pop the dispatch list
	bne	10$		; process the next entry
 
;	Command not found

	RptFld			; in case we're a RUST/RT shell
	tstb	s$yshe		; are we a command shell?	(added)
	bne	cu$rtx		; yes - send command to shell
cu$inv:	mov	#c$scmd,r0	; "?Invalid command"
	br	cl$abt		; start over

;	Call CLI command routine
;	
;	r0 ->	command line and field
;	r1 =	terminator
;	r5 ->	IOB (if relevant)
;
;	r2	undefined
;	r3 = 0	used by shell commands
;	r4 ->	command entry point
				
cl$cal:	add	(r4),r4		; r4 = command address
				;
	call	(r4)		; command dispatch
				;
	asrb	s$ycli		; single-line command?		(added)
	bcc	cl$agn		; no - get next command
				; yes - back to RUST/RT
cu$rty:	jmp	mo$rty		; return to RUST/RT		(added)
cc$rtx:				; RT command			(added)
cu$rtx:	jmp	mo$rtx		; send command to RUST/RT	(added)


;	CL$ZAP - Cleanup after abort and before a new command
;
;	o XXDP+ did not clear s$ybat or s$yqui during CLI command
;	  initialization, which was fine except in the case of
;	  Batch aborts.

cl$zap:	psh	r0		; save r0 (for message passing)
	call	em$rst		; reset EMT vector and PSW
	call	mo$rst		; restore monitor if required
	SetAbt	cl$abt,A	; generic CLI abort
	clrb	s$ybat		; clear batch mode		(added)
	clrb	s$yqui		; clear quiet mode		(added)
	clrb	s$ypnd		; destroy pending character	(added)
	TerMod			; use the terminal
	pop	r0		; get message back
	return


;	CL$ERR - Report CLI error
;
;	in	r0 ->	message

cl$err:	tst	r0		; gotta get a message?
	beq	10$		; not a message to you
	TypMon			; display message
	.if ne gto$c
	TypMon	#c$lbuf		; display command line		(added)
	.iff
	TypMsg	c$llin		; display command line		(added)
	.endc
	NewLin			;  
10$:	return


;	CLI messages

c$scmd:	.asciz	"?Invalid command: "
c$sadr:	.asciz	"?Odd address: "
c$sbab:	.asciz	<cr><lf>"?Batch fail: " ;			(added)
	.if ne xrt$c
c$sext:	.asciz	"EXERT.BIN"
	.endc

;	CLI strings

c$sqvs:	.ascii	"QV"<0><0>	; "QV" - Quick Verify switch

;	CLI command lookup table

	.macro	CLI$ nam,wld
	 .if ne abr$c
	  .asciz wld
	 .iff
	  .asciz nam
	 .endc
	.endm

	.byte	-1		; see 20$ above
c$lloo:	CLI$	"C",   "C*HAIN"	; Chain
;	CLI$	"CO",  "CO*PY"	; COpy
;	CLI$	"D",   "D*IRECTORY"; Directory
;	CLI$	"H",   "H*ELP"	; Help	
	CLI$	"L",   "L*OAD"	; Load
	CLI$	"ODT", "O*DT"	; Odt				(added)
	CLI$	"RT",  "RT"	; RT				(added)
	CLI$	"R",   "R*UN"	; Run
	CLI$	"S",   "S*TART"	; Start
;	CLI$	"T",   "TY*PE"	; Type
	.if ne xrt$c
	CLI$	"X",   "X"	; Exert				(added)
	.endc
	.if ne bat$c
	CLI$	"B",	"B"	; Batch immediate mode		(added)
	.endc
	.if ne dbg$c
	CLI$	"BPT", "BP*T"	; debug breakpoint		(added)
	.endc
	.byte	-1		; force missmatch 
	.even

;	CLI command dispatch table

	.MACRO	CLI$ ADR
	 .word	adr-.
	.ENDM

c$ldis:
c$lchn:	CLI$	cc$chn		; Chain
;	CLI$	cc$cop		; COpy
;	CLI$	cc$dir		; DIrectory  - DCL DIR command
;	CLI$	cc$hlp		; Help       - DCL XXHELP command
	CLI$	cc$loa		; Load
	CLI$	cc$odt		; Odt
	CLI$	cc$rtx		; RT
	CLI$	cc$run		; Run
	CLI$	cc$sta		; Start
;	CLI$	cc$typ		; T*ype
	.if ne xrt$c		;
	CLI$	cc$xrt		; eXert
	.endc			;
	.if ne bat$c		;
	CLI$	cc$bat		; Batch
	.endc
	.if ne dbg$c		;
	CLI$	cc$bpt		; BPt breakpoint
	.endc			;
	.word	0		; terminate list

	.if ne dbg$c
cc$bpt:	bpt			; debug breakpoint command
	return
	.endc


.sbttl	CLI Chain Load Start Run Exert ODT	    (overlay)	(CLI)

;	CLI CHAIN command	
;
;	Initiates an XXDP batch command file.
;
;	C filnam[/QV]
;
;	/QV (Quick Verify) terminates diagnostics after one pass.
;
;	Specifying the /QV switch sets S$YQVS to flag single pass
;	operation. XXDP does not clear the flag, thus all subsequent 
;	CHAIN commands 	effectively become single pass operations 
;	until a reboot. XXRT clears the flag.
;
;	o XXDP does not check that switches are preceded by '/'.

	.if ne bat$c
cc$bat: incb	b$acon		; flag batch console mode
	br	cu$chn		; call batch
	.endc

cc$chn:	ParFld			; get the field
	 br	cu$ifn		; invalid filename
	PshBat			; r0 -> end of copied file spec
	movb	#'.,(r0)+	; add filetype ".CCC"
	movb	#'C,(r0)	; ".C"
	movb	(r0)+,(r0)	; ".CC"
	movb	(r0)+,(r0)+	; ".CCC"
	clrb	(r0)		; terminate string

;	Parse/store switches, check for /QV
;
;	There's no syntax checking here. Any trailing command field
;	acts as a trigger to copy that field and the remainder of
;	the command line to the switch buffer. 24 bytes are reserved
;	for switches (but, again, no check is made for overflow).

	mova	s$yswi,r2	; /switch buffer
	clrb	(r2)		; assume no switches
	ParFld			; get an alphanumeric field
	 br	50$		; end of line
.if ne swi$c
	cmpb	-(r0),#'/	; got a switch?			(added)
	bne	cu$ifn		; nope - syntax error
.iff
	dec	r0		; blindly back up to assumed "/"
.endc
10$:	movb	(r0)+,(r2)+	; copy field and remaining line
	bne	10$		; r0 -> 0 if no field; terminates list
				;
	mova	c$sqvs,r0	; .ascii "QV"
	mova	s$yswi,r2	; the switch buffer
				;
20$:	movb	(r2),r1		; end of switches?
	beq	50$		; yes - fail
	cmpb	(r2)+,#'/	; "/"
	bne	20$		; must be found
	mov	r0,r4		; r4 -> candidate
30$:	cmpb	(r4)+,(r2)+	; r2 -> stored 
	beq	30$		; compare until missmatch
	cmpb	-(r2),#'/	; terminated by "/"
	beq	40$		; yes (multiple switches)
	tstb	(r2)+		; EOL? (pop back past terminator)
	bne	20$		; no - start over
40$:	mov	r1,s$yqvs	; ne => found, eq => not

;	Call mo$chn to copy/activate the batch process

50$:	bic	#scMAN$,@#52	; CMI clear manual intervention
cu$chn:	mov	#mobat.,r2	; block = 6 (location 6000)
	jmp	mo$chn		; read batch overlay and chain
				;
cu$ifn:	JmpAbt	#c$scmd		; "?Invalid command: ..."


;	CLI LOAD command
;
;	Loads a diagnostic or utility into memory.
;
;	L filnam[.typ]
;
;	o XXDP appends the file type ".BI?" to the file specification,
;	  regardless of whether user specifies a file type or not:
;
;	  filnam.BI?		no file type specified
;	  filnam.typ.BI?	file type specified
;
;	o CC$RUN uses this routine to load an image.

cc$loa:				; also called by cc$run
cu$loa:	ParFld			; get ye field 	(cu$run EPT)
cu$ifj:	 br	cu$ifn		; invalid filename
	mov	r0,r4		; r0/r4 -> field
10$:	cmpb	(r4)+,r1	; same as terminator?
	bne	10$		; no - loop until that happens
	movb	#'.,-1(r4)	; "."
	movb	#'B,(r4)+	; ".B"
	movb	#'I,(r4)+	; ".BI"
	movb	#'?,(r4)+	; ".BI?"
	clrb	(r4)		; ".BI?"<0>
       ;add	#4,c$lnxt	; advance next field pointer
				; sic] c$lnxt has no practical use
				; r0 -> "filnam.BI?"
	clr	r1		; r1 = load address default
	LoaFil			; and read another psuedo papertape
	return			;


;	CLI START command
;
;	Starts a loaded app at a specified address.
;
;	S[/count] [address]
;
;	o Starts at the app's default address if no address is specified.
;
;	o Can be used to restart an image after image exit.
;
;	o Octal address syntax errors are ignored (e.g. <S %%%>).

cc$sta:	call	cu$sta		; get a start address
	br	cu$act		; activate


;	CU$STA - Get /passes and start address for RUN and START
;
;	in	command field
;
;		call	cu$sta
;		bcs	fail	; note: bcs fail, bcc fine
;	
;	fine	r0 	start address
;		s$ysta	start address or #1
;	
;	abort	"?Odd address"
;
;	o Called by cu$sta to pickup the start information.
;
;	o Octal address syntax errors are ignored (e.g. <S %%%>).
;
;	o XXDP supports the pass count only batch mode. XXRT	(added)
;	  adds CLI support.

cu$sta:	mov	#1,r0		; r0 = 1 - s$yrpt default
	mov	r0,s$ysta	; default start address flag = 1
				;
	cmp	r1,#'/		; /passes?			(added)
	bne	10$		; nope
	ParDec			; translate decimal count
	 br	30$		; oops
10$:	mov	r0,s$yrpt	; set the repeat count (#1 or explicit)

	ParOct			; got a start address
	 br	20$		; no address, use default
	bit	#1,r0		; odd adresses are just odd
	bne	30$		; it's not fine
	mov	r0,s$ysta	; set start address
20$:	return
30$:	JmpAbt	#c$sadr		; it's not fine


;	CLI RUN command
;
;	Initiates a diagnostic or utility.
;
;	R filnam[/pass][ start][ ; comment]
;
;	XXRT adds support for a pass count and ctrl-c abort. 	(added)
;
;	o RUN uses CU$LOA to parse the filename and load the image.
;	  However, the Load command does not accept a start address,
;	  and in fact overwrites the end of its filename field with
;	  the default file type (".BI?").
;
;	  So, RUN initially skips the filename field (ParFld below),
;	  and then calls CU$STA to pickup the start address. It then
;	  restores the initial field and calls CU$LOA to parse and 
;	  load the image.

	.enabl	lsb
cc$run:	ParFld			; get filespec
	 br	cu$ifj		; invalid filename jump
				;
	psh	r0		; save current field
10$:	call	cu$sta		; get pass count and start address
	pop	c$lnxt		; c=? so cc$loa can reparse filename
				; c=? (pop the stack in both cases)
	bcs	60$		; c=? start address was bad
	call	cu$loa		; load the program
	fall	cu$act		; full activation


;	CU$ACT - Activate CLI image
;
;	Called by CLI Run, Start and LoaSup.
;
;	o R <app>/n aborts diagnostic after n passes.		(added)
;
;	o ctrl-c aborts a diagnostic at end-of-pass.		(added)
;
;	@#52 is the job status word.
;
;	CC$CHN:	bic	#smMAN$,@#52	; CMI
;	CU$ACT:	mov	#smMAN$,@#52	; SMI

	assume	s$yact-s$ysta eq 2
cu$act:	mova	s$ysta,r0	; r0->s$ysta
	cmp	#1,(r0)		; cmp s$yact,#1 - #1 => diagnostic
	beq	20$		; is diagnostic
	mov	(r0)+,(r0)	; mov s$ysta,s$yact
	br	30$		; has explicit start address
				;
20$:	cmp	(r0)+,(r0)	; cmp #1,s$yact - explict start address?
	bne	30$		; yes - use that
	mov	#200,(r0)	; mov #200,s$yact - use standard start address
				;
30$:	clr	@#TKB		; clear any hanging ctrl-c (paranoia)
	call	40$		; push cu$pas address and continue at 40$

;	End-of-pass co-routine

cu$ret:	dec	s$yrpt		; all repeats done?		(added)
	beq	60$		; yes
	cmpb	@#TKB,#ctrlc	; typed ctrl-c?			(added)
	beq	60$		; yes - exit
	callr	em$pr7		; no - set PR7 and do another pass

;	Activate continues

40$:	mov	#42,r0		; r0   -> @#42 - app return path
	pop	(r0)		; @#42 -> cu$pas coroutine
				;
;	Setup low memory	; r0 = 42
				;
	movb	d$runi,-(r0)	; 41 - device unit
	movb	d$pmed,-(r0)	; 40 - device media code
	cmp	-(r0),-(r0)	; 34 - skip two words
	mov	s$yemt+2,-(r0)	; 32 - saved EMT vector + 2
	mov	s$yemt,-(r0)	; 30 - saved/overwritten EMT vector
	mov	#scMAN$,@#52	; 52 - set manual intervention (SMI)
				;
;	Activate CLI image	;
				;
	mov	sp,c$ustk	; save system stack
				;
	call	@s$yact		; image start address
				; diagnostic return path
60$:	mov	c$ustk,sp	; restore CLI stack
	callr	em$rst		; restore EMT vector, PSW and return
	.dsabl	lsb


;	EXERT command						(added)
;
;	Activate EXERT.BIN
;
;	X command
;
;	o EXERT.BIN is an XXRT maintenance app (cus:exert.r).

.if ne xrt$c
cc$xrt:	mova	c$sxrt,r0	; r0 -> "EXERT.BIN"
	clr	r1		; no load offset
	LoaFil			; lock and load
	callr	(r1)		; kaboom
.endc


;	CLI ODT command						(added)
;
;	Examines and modifies memory.
;
;	ODT [address][=value][/]
;
;	o The ODT command lives in the unused GAP area between the
;	  Batch region and the transient region.

cc$odt:	cmp	b$asig,#odsig.	; is ODT resident?
	beq	10$		; yes
	mov	#moODT.,r2
	mova	x$xbat,r3	; r3 = -> 12000/152000
	call	mo$rea		; read the overlay
10$:	jmp	od$odt-$O


.sbttl	Static region				    (static)	(API)

;	End of CLI/Batch overlay region				
;
;	Determine the maximum overlay length.
;
;	ovllen. = max (batlen., ovllen.); work out max overlay length

	clilen. == .-c$lreg		; CLI overlay length
	ovllen. == clilen.		; assume CLI overlay is the longer
	.if gt batlen.-clilen.		; check assumption
	 ovllen. = batlen.  		; Batch is longer
	.endc				;

map$	x$xcom 12000+ovllen. cliend clifre

;	The static area starts here.
;
;	The code below is permanently resident and not overwritten.
;
;	MOVR etc can now be used instead of MOVA.


.sbttl	EMT engine				    (static)	(EMT)

;	EM$ENG - EMT system service dispatch engine
;
;	--------------------
;	EMT CALLING PROTOCOL
;	--------------------
;
;	Registers are used to pass information to and from services:
;
;	mov	arg1,r0
;	mov	arg2,r1
;	emt	xxx
;
;	R0/R1	R0/R1 are the workhorses for service arguments and results.
;		The dispatcher does not save/restore R0 or R1, however
;		service routines modify R0/R1 only when functionally
;		appropriate. 
;
;	R2..R4	R2, R3 and R4 are saved/restored by the dispatcher.
;		Two services (SpcAsc & CmpSpc) pass arguments in R2.
;
;	R5	R5 is not saved/restored by the dispatcher. R5 is reserved
;		exclusively for its use as a pointer to the I/O control
;		block (d$riob). Utilities must preserve the monitor R5
;		setting when using these calls.
;
;		Set  by: GetLin, OpnFil, in$eng, mo$rea
;		Used by: GetCha, ReaByt, ReaWrd, ReaNxt, LoaSup 
;
;		o GetLin and GetCha access R5 only in Batch mode.
;		o Utilities may redirect r5 to point to loadable drivers.
;		  However, a survey shows that the monitor is never called
;		  to open or read files from loadable drivers.
;
;
;	-------------------
;	EMT RETURN PROTOCOL
;	-------------------
;
;	There are four service return paths: plain, skip, cbit and abort.
;
;	PLAIN:
;	------
;	Services such as GetDat have no error conditions.
;
;	o GetTer returns a null character if none available.
;	o GetLin returns a pointer to a null for an empty line.
;
;	SKIP: ParFld CmpSpc ParDec ReaNxt
;	-----
;	The service returns to the location immediately following the
;	EMT for a "fail" condition, but skips that location for a "fine"
;	condition. In the example below the "fail" path is taken for
;	EOL (end of line) or EOF (end of file).
;
;		GetFld
;		 br	eol	; fail
;		...		; fine
;
;	The fail instruction must be a single word instruction and is
;	traditionally indented by a single space to indicate it's usage.
;
;	System service calls trigger the skip by modifying the EMT call
;	routine return address on the stack.
;
;	o The skip return is employed within the monitor itself.
;
;	CBIT: GetLin GetCha ParOct ReaByt ReaWrd
;	-----
;	Some services use the carry bit to report status. Common PDP-11
;	usage is to report errors with the carry-set condition. XXDP+
;	uses carry-clear to report failure for services and some routines.
;
;		GetCha
;		bcc	eof	; fail
;		...		; fine
;
;	Service routines use em.ps to set the c-bit for the emt return.
;
;	SomApi:	...
;		bis	#cbit.,em.ps(sp)
;
;
;	o V2 changes all Cbit returns into Skip returns, and in doing so
;	  creates all manner of compatibility issues and workarounds.
;
;	ABORT: GetLin GetCha OpnFil LoaSup ReaBlk dr$opn dr$rst dr$tra
;	------
;	Ctrl-c, checksum errors, media read errors and file-not-found
;	use the system SetAbt/JmpAbt mechanism to report errors.


;	EM$ENG - EMT system service dispatcher
;
;		mov	x,r0
;		mov	y,r1 or r2
;		EMT	code
;
;	o No check is made for invalid EMT codes.
;
;	r0/r1	  arguments/results
;	r2/r3/r4  saved
;	r5	  shared (as described above)

	stack	r2,r3,r4,pc,ps
	em.ps = sp.ps+2			; API routine PSW offset
em$eng:	pshs	<r4,r3,r2>		; save registers
					;
	bic	#cbit,sp.ps(sp)		; clear return c-bit
					;
	mov	sp.pc(sp),r4		; get the pc
	movb	-2(r4),r4		; r4 = EMT code
	asl	r4			; code as word offset
					;
	callx	@e$mdis(r4)		;\ call EMT service
	 br	20$		;plain	;| fail - don't alter return address
	add	#2,sp.pc(sp)	;skip	;/ fine - propagate skip return
					;
20$:	pops	<r2,r3,r4>		; restore registers
em$rti:	rti				; return to caller


;	EM$RST - Restore EMT vector
;
;	Diagnostics are free to obliterate the EMT vector (@#30/32).
;	EM$RST is called by CLI system restart, CLI and batch image
;	exit to restore the EMT vector and to restore PR7.

em$rst:	movr	#em$eng,@#v$eemt	; rebuild EMT vector
	mov	#340,@#v$eemt+2		; PR7
	fall	em$pr7			; now rebuild the PSW

;	Reset the PSW to PR7 (#340)
;
;	XXDP is designed to run at PR7, blocking all interrupts.
;	Apps often alter priority. This routine resets PR7.

em$pr7:	psh	#340			; the PSW to be 
	call	em$rti			;\em$rti RTI's to 10$
	return				;/setting PSW=340


;	E$MDIS - EMT dispatch table

	.MACRO	API$ adr
	 .wordr adr
	.ENDM

e$mdis:	API$	GetLin	; 0  GetLin - Get command line
	API$	ParFld	; 1  ParFld - Parse command field
	API$	TypMon	; 2  TypMon - Type relocated monitor message
	API$	TypMsg	; 3  TypMsg - Type message
	API$	PutCha	; 4  PutCha - Put terminal character
	API$	GetTer	; 5  GetTer - Get terminal, return if none available
	API$	GetCha	; 6  GetCha - Get terminal character
	API$	NewLin	; 7  NewLin - Display newline
	API$	PutTab	; 10 PutTab - Display tab
	API$	ParOct	; 11 ParOct - Parse octal string
	API$	OpnFil	; 12 OpnFil - Open file
	API$	CloFil	; 13 CloFil - Close file (deprecated)
	API$	LoaFil	; 14 LoaFil - Load program file
	API$	ReaWrd	; 15 ReaWrd - Read word
	API$	ReaByt	; 16 ReaByt - Read byte
	API$	PutTer	; 17 PutTer - Put terminal character
	API$	ReaNxt	; 20 ReaNxt - Read next block
	API$	ReaBlk	; 21 ReaBlk - Read specified block	
	API$	SetAbt	; 22 SetAbt - Set abort address
	API$	JmpAbt	; 23 JmpAbt - Jump to abort location	
	API$	CmpSpc	; 24 CmpSpc - Compare file specs
	API$	SpcAsc	; 25 SpcAsc - Convert rad50 spec to ascii
	API$	SetLin	; 26 SetLin - Set command line address	
	API$	GetDat	; 27 GetDat - Get system date
	API$	OctAsc	; 30 OctAsc - Convert octal value to ascii	
	API$	GetDev	; 31 GetDev - Get system device info	
	API$	RptFld	; 32 RptFld - Repeat command line field
	API$	LptMod	; 33 LptMod - Lineprinter output mode
	API$	TerMod	; 34 TerMod - Terminal output mode	
	API$	LoaSup	; 35 LoaSup - Load DRS supervisor	
	API$	ParDec	; 36 ParDec - Parse decimal ascii string	
	API$	PadTer	; 37 PadTer - Pad terminal output (deprecated)
	API$	PshBat	; 40 PshBat - Push batch file
	API$	PopBat	; 41 PopBat - Pop batch file
	API$	GetCom	; 42 GetCom - Get system communication area address	
	API$	GetSys	; 43 GetSys - Get system information address
			;	    - EMT 43 previously deprecated GetDrv
	API$	TypBrk	; 44 TypBrk - Display breakthough message	


.sbttl	Monitor engine				    (static)	(monitor)

;	Monitor engine
;
;	These routines manage all the I/O necessary to restore the
;	monitor, to swap CLI and Batch overlays and to reread the
;	XXRT init/exit code and RT-11 monitor back to low memory.
;
;	MO$RTX - manages the return to the host RUST/RT system
;	MO$RST - restores the monitor during image exit
;	MO$REA - performs all monitor image I/O (with MO$TRA)
;	MO$BAB - manages batch abort back to CLI
;	XX$RST - manual system restart - restores the CLI first
;	MO$CHN - completes the CLI->Batch transition and return
;	MO$CLI - reads the CLI overlay in
;	MO$OVL - utility to read an overlay
;
;	These are the monitor block numbers of the areas of interest:
;
;	moBAT. = 6		; batch area block
;	moTRA. = 8.		; transient area block
;	moCLI. = 10.		; cli area block
;
;	o The state of the EMT vector is not known for some entry points.
;	  These routines do not use EMT services.


;	MO$RTX - Batch/CLI RT command helper			(added)
;
;	Return to or send a command to RUST/RT.
;
;	MO$RTX - execute command
;	MO$RTY - return from single-line command

mo$rtx:	ParFld			; check RUST single-line command 
mo$rty:	 clr	r0		; EOL - no command returned
	pshr	#cl$eng		; restart address
	psh	r0		; pass monitor command (if any)
				;
	psh	#rt$res		; resusicate RUST/RT after transfer
	mov	#svblk.,r2	; block number
	mov	#svres.,r3	; buffer address
	mov	#svwct.,r4	; word count
	br	mo$tra		; transfer buffer and control


;	MO$RST - Restore the monitor transient area
;
;	o Restore the transient area if a checksum missmatch occurs.

;	o Check to see if the transient area has been overwritten.

mo$rst:	mov	s$ytra,r0	; transient area
	clr	r1		; checksum
10$:	add	(r0)+,r1	; accumulate checksum
	cmp	r0,s$yper	; reached the permanent area?
	bne	10$		; nope
	cmp	s$y5ck,r1	; have we changed?
	beq	mo$ret		; no - we're done - return

;	Restore the transient area

	mov	#motra.,r2	; block = 8
	mov	s$ytra,r3	; buffer = s$ytra
	fall	mo$rea		; restore 512. words


;	MO$REA - Read 512. words from the monitor file
;	MO$TRA - Read specified word count.
;
;	in	r2 =	block
;		r3 ->	buffer
;		r4 =	word count
;
;	local	r5 ->	d$riob 
;
;	out	r2..r4	burnt (by the driver)
;
;	o All monitor image I/O flows through MO$REA and MO$TRA.
;
;	o MO$REA restores the IOB R5 pointer.

mo$rea:	mov	#512.,r4	; word count
mo$tra:	movr	#d$riob+io.blk,r5;r5 -> io.blk
	mov	r2,(r5)		; io.blk - r2 = block
	mov	r3,-(r5)	; io.buf - r3 = buffer
	mov	r4,-(r5)	; io.wct - r4 = word count
	tst	-(r5)		; r5 -> d$riob
	clr	f$isck		; clear batch saved checksum
	callr	@dr.rst(r5)	; read


;	MO$BAB - Batch abort					(added)
;
;	System errors did not actually abort XXDP+ batch files. Instead
;	XXDP+ batch files would spiral out of control. XXRT solves this
;	problem here.
;
;	MO$BAB pushes a return to CL$BAB (CLI batch abort) and then
;	branches to MO$CHN 10$ which rereads the CLI overlay. The only
;	other task is to clear S$YBAT, which CL$ENG handles.

mo$bab:	pshr	#cl$bab		; CLI batch abort		(added)
	br	mo$cli		; read the CLI back in

;	XXDP manual system restart
;
;	XX$RES, at the end of the image, jumps here to restart XXRT.
;	
;	XXDP+ restart assumed that the CLI overlay was loaded.	(added)
;	System restart from a Batch environment failed utterly.
;	XXRT solves the problem by first rereading the CLI overlay.
;
;	o We assume that the system disk is currently loaded.

	assume	basig. ne clsig.; compare signatures	
xx$rst:	pshr	#cl$eng		; system restart		(added)
	cmp	c$lsig,#clsig.	; CLI loaded?
	beq	mo$ret		; yes - no need to reread
	br	mo$cli		; restore CLI overlay


;	MO$CHN - Chain management
;
;	1. Copy batch region to overlay region
;	2. Call the batch engine.
;	3. Reload the CLI overlay when batch completes.
;
;	in	r2 =	moBAT.

mo$chn:	call	mo$ovl		; read/copy batch area
				; 
	call	ba$eng+$$	; call batch
				;
	PopBat			; restore CLI context
				;
mo$cli:	clrb	s$yqui		; read the CLI back in
	mov	#moCLI.,r2	; r2 = block 10. (12)
	fall	mo$ovl		; read/copy CLI overlay

;	MO$OVL - Read and copy an overlay
;
;	1. Read an overlay into the batch region.
;	2. Copy the overlay into the CLI region.
;
;	in	r2	monitor block number
;
;	out	r2..r4	burnt
;
;	o XXDP uses read-and-copy method for the Batch overlay.
;	o XXDP reads the CLI directly into place.
;	o XXRT uses read-and-copy for both.			(added)

mo$ovl:	movr	#x$xbat,r3	; r3 = -> 12000/152000
	call	mo$rea		; read the overlay into memory
	movr	#x$xbat,r2	;
	movr	#x$xper,r3	; dest overlay area
	mov	#ovllen./2,r4	; words to copy
20$:	mov	(r2)+,(r3)+	; copy overlay area
	dec	r4		; word by word
	bne	20$		; leaving none out
mo$ret:	return			; helper return


.sbttl	System Data & Communication area	    (static)	(data)

;	System information database
;
;	o All the system impure data is stored here, with the
;	  exception of the driver open and transfer routines
;	  (DR$OPN, DR$TRA).
;
;	o The order of entries is mostly set in stone.
;
;	S$YSYS - System information area
;
;	o GetSys returns a pointer to S$YSYS.

s$ysys:				;  GetSys returns this address
s$yswi:	.blkb	24.		;  batch/CLI switch buffer
s$ygto:	.rept	58.		;  batch GOTO buffer		(hack)
	.word	123456		;  stack pattern
	.endr			;  58. word stack
s$ystk:				;  system stack top
s$ytra:	.word	0		;  -> .5k transient area	(init)
s$yper:	.word	0		;  -> permanent memory area	(init)
h$wltc:	.word	177546		;  line clock
h$wkwp:	.word	172540		;  KW11P programmable clock
s$yrel:	.word	0		;  relocation constant		(init)
s$yrpt:	.word	0		;  diagnostic repeat count
s$ydev:	.word	0		;  -> d$pdev: .ascii "DDu"<lmd>	(init)
s$ysup:	.word	0		;  DRS supervisor load address	(init)
s$ytps:	.word	TPS		;  TPS/LPT csr pointer		(init)
s$ytpb:	.word	TPB		;  TPB/LPB buffer pointer	(init)
f$ibct:	.word	0		;  ReaByt file byte count
s$ytop:	.word	0		;  -> top of memory		(init)
f$iptr:	.word	0		;  file buffer pointer
f$ilck:	.word	0		;  LDA load file read checksum
c$llin:	.wordr	c$lbuf		;\ resident command pointer	(init)
c$llen:	.word	clavl.		;/ line length			(init)
c$lnxt:	.word	0		;  -> next command field
f$ipos:	.word	0		;  current file position
f$isvp:	.word	0		;  saved/restored file position
c$lfld:	.word	0		;  -> current field
	.word	0		;  ??? no known function
s$ydat:	.word	71265		;  system date (always 31-DEC-99)
s$yabt:	.word	0		;  setabt/jmpabt address
s$yemt:	.word	0,0		;  saved EMT vector during image load
s$ysta:	.word	177777		;  image START command address and type
s$yact:	.word	177777		;  image activate address
f$irck:	.word	177777		;  ReaBlk checksum
f$isck:	.word	0		;  Batch saved ReaBlk checksum
s$y5ck:	.word	0		;  .5k area checksum		(init)
				;  
s$yf01:	.byte	0		; 
s$yf02:	.byte	0		;  
s$yf03:	.byte	0		;  
s$yf04:	.byte	0		;  
s$ycol:	.byte	0		;  column (for tabbing)
s$ypnd:	.byte	0		;  pending input character
	.byte	0		;  ne => GetLin active
s$yqui:	.byte	0		;  negative => quiet mode
	.byte	0,-1		;\ command line backstop
c$lbuf:	.blkb	clavl.		;| command line buffer
	.word	0   		;/ command line terminator
b$asfn:	.blkb	10.		;  saved .ascii batch file name
b$afnm:	.blkb	10.		;  .ascii batch file name
f$ibuf:				;\ file buffer 
f$irec:	.blkw	256.		;| file record  
	;....			;| record text
	.word	0		;/ buffer parse & print terminator

;	S$YCOM - High memory syscom area
;
;	o DRS stores a copy the GetCom pointer, accesses S$YPGS and
;	  copies the DRS-marked list of entries below. DRS makes
;	  multiple uses of GetCom to check system parameters. DRS
;	  apps report errors via S$YERR, which batch checks.
;
;	o DRS uses the first three entries to check whether a media
;	  unit to be tested is the same as the system device unit.
;	  Because of this we can identify the second entry as probably
;	  being the media's device controller (thus S$YCON). However,
;	  XXDP does not initialize or access this entry.
;
;	o GetCom returns a pointer to S$YCOM.

s$ycom:				;  GetCom returns this address
s$ycsr:	.word	0		;\ CSR address			(init)
s$ycon:	.word	0		;| controller unit		
s$yuni:	.word	0		;| unit number			(init)
				;|
s$ycfg:	.word	0	       ;/| config flags (LPT$ etc)	(init)
s$ylpt:	.word	0	       ;|| LPT CSR if present		(init)
s$ykwd:	.word	0	       ;|| kwords memory size		(init)
s$yltc:	.word	0	       ;d|\ LTC ISR and block
	.word	6	       ;||| LTC priority
	.word	100	       ;r|| LTC clock vector
s$yltk:	.word	60.	       ;||/ LTC clock-ticks    (50hz=50.)(init)
s$ykwp:	.word	0	       ;s|\ KWP ISR and block
	.word	6	       ;||| KWP priority
 	.word	104	       ;||| KWP vector
s$yktk:	.word	60.	       ;\|/ KWP clock-ticks    (50hz=50.)(init)
				;|	
s$yqvs:	.word	0		;| /QV quick verify switch
s$ybat:	.byte	0		;| batch mode and level
	.byte	0		;| ??? unused
s$ypgs:	.word	-1		;| MMU 32w-pages-1 (777=16kw-1pg)(init)
s$yerr:	.word	0		;/ DRS apps report errors to batch here
;
;	XXRT area						(added)
;
;	o This data is added for XXRT. The XXRT area must follow
;	  the syscom area.

s$yiob:	.wordr	d$riob		;  IOB pointer
f$inxt:	.word	0		;  RUST/RT next block
f$ilst:	.word	0		;  RUST/RT last block
				;
s$yhst:	.byte	0		;  host:     -1=RUST/BOOT, 0=RUST, 1=RT-11
s$yemu: .byte	0		;  emulator: -1=SimH,      0=none, 1=V11
s$yscp:	.byte	1		;  VT100 mode (0=noscope, 1=scope)
s$yshe:	.byte	1		;  XXRT-as-Shell
s$ycli:	.byte	0		;  host CLI single-line command flag
s$ynew:	.byte	0		;  CLI prompt newline control
s$yver:	.byte	3		;  system version (XXRT starts as V3)
s$yupd:	.byte	0		;  system update
	.even

;	Driver area
;
;	o This data area is defined by the XXDP+ driver standard.
;
;	o This area need not be contiguous.

d$rcom:	.wordr	f$ibuf	;752	;\ dr.buf		    (init)	
	.word	0	;754	;| dr.ent - entry number in segment
d$rfnm:	.rad50	/   /	;756 	;| dr.fnm - .rad50 /filnamtyp/
	.rad50	/   /	;760 	;|          copied here by dr$opn
	.rad50	/   /	;762 	;|          along with dr.sbl below
	.word	0	;764	;| dr.sbl - first file block
			;	;|  
d$rdis:	.wordr	dr$opn	;766	;\ dr.opn - open file	    (init)
	.wordr	dr$rst	;770	;| dr.rst - restore monitor (init)
	.wordr	dl$tra	;772	;| dr.tra - transfer	    (init)
	.wordr	dr$dev	;774	;| dr.dev - device name	    (init)
d$runi:	.byte 	0	;776    ;| dr.uni - device unit	    (boot)
	.byte 	0	;777 	;| dr.sts - operation status
d$riob:			;	;| IOB
d$rcsr:	.word	dlcsr.	;000	;| CSR 			    (boot)
	.word	0	;002	;| io.wct
	.word	0	;004	;| io.buf
	.word	0	;006	;| io.blk 
	.wordr	d$pufd	;010	;| io.ufd - relocated	    (init)
			;	;|
i$ospc:	.blkb 	12.	;012	;/ io.spc  .asciz "filnam.typ"<0>
			;	;
d$rend:			;026	;  driver area end

;	Monitor impure data
;
;	o These stack pointers were originally local variables in the
;	  Batch and CLI overlays. Moved here to make the code pure.
;
;	o Order and placement are not important here.

b$astk:	.word	0		; Batch stack
b$ustk:	.word	0		; Batch BU$ACT stack
c$ustk:	.word	0		; CLI CU$ACT stack
b$acon:	.byte	0		; run batch in console mode flag
	.byte	0		; unused 


.sbttl	LoaFil					    (static)	(API)

;	LoaFil - Load file service				(EMT 14)
;
;	Loads a formatted binary utility or diagnostic program.
;
;	in	r0 ->	ascii filespec
;		r1 =	load base address
;	
;		LoaFil
;
;	fine	r1 ->	activate address
;	
;	abort	r0 -> 	"?<Message> filnam.typ"
;
;	o XXDP+ does not check for incoming EOF and may loop 	(added)
;	  forever if a binary file is corrupt or not a binary
;	  file. XXRT detects and reports such errors.
;
;	o XXDP+ uses TypMon to report errors which are not	(added)
;	  displayed in QUIET mode. XXRT uses TypBrk (like DR$OPN).
;
;	o XXDP+ allowed images to partly overwrite the monitor	(elided)
;	  and then halted, requiring the user to manually start
;	  the program. XXRT does not permit overwriting. In any
;	  case, none of the XXDP22/XXDP25 diagnostics overwrite
;	  monitor. This functionality probably applied early on
;	  to systems with less than 28kw main memory.
;
;	o The DRS-enabled diagnostic startup protocol is implemented
;	  here by preloading @#200/202 with <.WORD 137,2100>, aka
;	  <JMP @#2100>.

LoaFil:	mov	r1,r3		; r3 = base address
				;
	movr	#s$yemt,r2	; EMT vector can't be modified here
	mov	@#v$eemt,(r2)+	; so we save it to a temp buffer
	mov	@#v$eemt+2,(r2)+; which is later copied into place
				;
	mov	#137,@#200	; 200/202: jmp @#2100
	mov	#2100,@#202	; @#2100 is the default DRS start address
				;
	OpnFil			; look for the file (aborts if missing)

;	r0	incoming byte
;	r1	store address
;	r2	record size
;	r3 	load base address (from caller r1)
;	r4	temp (used for emt vector process)
;	r5	IOB

10$:	clr	f$ilck		; zap load checksum
	ReaByt			; looking for start-of-record
	bcc	100$		; EOF - "?Invalid file"		(added)
	decb	r0		; which must be a one
	bne	10$		; try again
	ReaByt			; which is followed by a null
	tstb	r0		; got a null?
	bne	10$		; not today
				;
	ReaWrd			; next comes the record byte count
	mov	r0,r2		; r2 = record size
				;
	ReaWrd			; now we want an address
	mov	r0,r1		; r1 = load or start address
	add	r3,r1		;    + base address
	sub	#6,r2		; subtract header size from byte count
	blt	70$		; 18-bit extension - ignore & test checksum
	beq	80$		; zero is a transfer record (no checksum)

;	Read LDA record

20$:	ReaByt			; read the next data byte
	bcc	100$		; EOF - "?Invalid file"		(added)
				;
	cmp	r1,s$ytra	; overwriting transient area?
	blo	30$		; no
	movr	#m$sbig,r0	; "?File too big" abort
	br	lf$abt		; abort

;	Handle EMT vector overwrite

30$:	mov	r1,r4		; r1/r4 -> target address
	sub	#v$eemt,r4	; r4 = 0..3
	cmp	r4,#4		; in EMT vector range?
	bhis	50$		; nope
	movbr	r0,s$yemt(r4)	; store it - run/load copies it into place
	tstb	(r1)+		; skip it
	br	60$		; and proceed as if nothing had happened

;	Store a byte and loop

50$:	movb	r0,(r1)+	; wow - actually store a byte
				;
60$:	dec	r2		; more bytes in record?
	bne	20$		; yes

;	End of record, handle checksum

70$:	ReaByt			; read checksum byte
	tstb	f$ilck		; the load checksum must be zero
	beq	10$		; it is - get next record
	movr	#m$schk,r0	; "?Checksum error" abort
	br	lf$abt		; display and abort

;	End of load

80$:	mov	r1,s$yact	; store activate address
90$:	return			; and we're done here

;	Error messages include file name
;
;	o XXRT uses TypBrk rather than TypMon to make sure	(added)
;	  abort messages get seen in quiet mode.

100$:	movr	#m$sivf,r0	; "?Invalid file" abort
lf$abt:	TypBrk			; dr$opn EPT
	TypBrk	#i$ospc,r	; "?Invalid file: MYFILE.BIC"
	NewLin			;
	JmpAbt	#0		;

m$schk:	.asciz	"?Checksum error: " ; checksum error
m$sbig:	.asciz	"?File too big: "   ; what it says
m$sivf:	.asciz	"?Invalid file: "   ; likewise			(added)
	.even


.sbttl	ReaWrd ReaByt ReaBlk ReaNxt OpnFil	    (static)	(API)

;	ReaWrd - Read word service				(EMT 15)
;	
;	Reads two bytes from the open file.
;
;	in	r5 ->	file IOB
;
;		ReaWrd
;		bcs	fine
;		bcc	fail	; EOF
;
;	fine	r0	word
;	fail	r0	undefined
;
;	abort	"?I/O error" from ReaBlk

ReaWrd:	ReaByt			; get another byte 
	bcc	rb$ret		; end of file - return
	mov	r0,r4		; save first byte
	ReaByt			; read another
	bcc	rb$ret		; oops - end of file
	swab	r0		; new byte to high byte
	bis	r4,r0		; combine
	br	rb$sec		; propagate good cbit return


;	ReaByt - Read byte service				(EMT 16)
;
;	Reads a single byte from the open file.
;
;	in	r5 -> file IOB
;	
;		ReaByt
;		bcs	fine
;		bcc	fail	; EOF
;
;	fine	r0	word
;	fail	r0	undefined
;
;	abort	"?I/O error" from ReaBlk
;
;	o Most XXDP monitor and app  routines ignore the EOF
;	  condition. XXRT adds EOF checks to LoaFil.
;
;	o ReaByt does not increment f$ipos file position. GetCha
;	  and GetLin manage f$ipos file position because it applies
;	  only 	to batch files.
;
;	o XXDP has 510. bytes data per block. XXRT has 512.

ReaByt:	tst	f$ibct		; got more bytes to eat?
	bgt	10$		; yes
	tst	io.blk(r5)	; got another block?
	beq	rb$ret		; fail - return
	call	ReaBlk 		; ReaBlk
	mov	f$inxt,io.blk(r5); link file forward
	mov	#512.,f$ibct	; 512 bytes of data per block
	movr	#f$irec,f$iptr	; relocated data record pointer

;	Get next byte

10$:	clr	r0		; clear result
	bisb	@f$iptr,r0	; get byte without sign extension
	add	r0,f$ilck	; add to the LoaFil checksum
	inc	f$iptr		; buffer pointer
	dec	f$ibct		; count down
rb$sec:	bis	#cbit,em.ps(sp)	; fine
rb$ret:	return


;	Reablk - Read Block service				(EMT 21)
;
;	Reads a block and computes the block checksum.
;
;	in	r5 ->	IOB
;		io.blk	block number
;
;		ReaBlk
;	fine	...
;	fail	abort	"?I/O error"
;
;		call	rb$chk
;
;	out	r0/r1	preserved
;		r2	burnt
;		r3 =	0
;		r4 =	checksum - used by GetLin
;		f$irck=	checksum
;
;	XXDP and XXRT have quite different ideas about file structure.
;	XXDP binary files begin with a one word link to the subsequent
;	block followed by 255. words of data. XXRT files are contiguous
;	with 256. word data blocks. This routine does most of the work
;	of making RT-11 files look like XXDP files.

ReaBlk:	mov	dr.buf(r5),io.buf(r5); buffer
	mov	#256.,io.wct(r5); word count
	call	@dr.tra(r5)	; transfer 

;	Mimic XXDP file structure behaviour

	mov	io.blk(r5),r2	; the next RT-11 block		(added)
	inc	r2		;  is the current block + 1
	cmp	r2,f$ilst	; a block too far?
	blo	10$		; no - we're good
	clr	r2		; yes - signal EOF
10$:	mov	r2,f$inxt	; store next block

;	Calculate the block checksum
;
;	I'm not sure why RB$CHK adds one to the checksum (<inc r4>),
;	however it could be related to the mechanism used to force
;	a reread of the batch file which is achieved with <clr f$isck>.
;	See BA$ENG et al.

rb$chk:				; GetLin entry point
	mov	dr.buf(r5),r2	; point to buffer
	mov	#256.,r3	; our counter
	clr	r4		; our checksum
10$:	add	(r2)+,r4	; accumulate
	dec	r3		; count
	bne	10$		;
	inc	r4		; avoid matching zero checksum?
	mov	r4,f$irck	; new file read checksum
	return


;	ReaNxt - Read next block service			(EMT 20)
;
;	Reads the next block from the input file.
;
;	in	f$inxt	next block
;
;		ReaNxt
;	fail	 br	eof
;		...
;
;	abort	abort	"?I/O error"

ReaNxt:	mov	f$inxt,io.blk(r5); advance to next block
	beq	10$		; there is no next block - fail
	ReaBlk			; read it
	add	#2,(sp)		; skip return
10$:	return


;	OpnFil - Open file service				(EMT 12)
;
;	Opens a specified file for input.
;
;	in	r0 ->	ascii "filnam.typ"
;
;		OpnFil
;
;	out	r1 ->	.rad50 /filnamtyp/ (dr.fnm)
;		r5 ->	d$riob - system I/O block
;
;	abort	dr$opn	dr$opn aborts for file not found
;
;	o OpnFil formats the file spec as space-filled template.
;	  Where "_" represents the space, the name "XXX.SYS" becomes:
;
;	  "XXX___.SYS"
;	   0123456789
;
;	o XXDP V1/V2 save a word by branching back to 20$ after	(added)
;	  <dec r3> to check for zero byte termination. A side
;	  effect is that OpnFil ends up discarding all filetypes
;	  except the last.
;
;	  In fact, for XXDP, only file specs that have 6-character
;	  file names can successfully specify a file type. All XXDP
;	  documentation examples in this regard show 6-character file
;	  names.
;
;	  XXRT fixes this by only accepting the first file type.
;
;	r1 ->	io.spc(r5)
;	r2 ->	ditto
;	r3 =	.byte 10.,10.

OpnFil:	movr	#d$riob,r5	; r5 -> IOB
	movr	#i$ospc,r1	; r1 -> io.spc
	mov	r1,r2		; r2 -> io.spc
	mov	#10.*256.+10.,r3; r3: .byte 10.,10.
10$:	movb	#space,(r2)+	; space fill the name 
	decb	r3		; all ten (low byte counter)
	bne	10$		;
				; r1 -> io.spc
	mov	r1,r2		; r2 -> io.spc
	swab	r3		; r3 = 10. (high byte counter)
	clr	r4		; filetype flag			(added)
20$:	tstb	(r0)		; end of string?
	beq	40$		; surely
	cmpb	(r0),#'.	; at the file type?
	bne	30$		; no
	com	r4		; second filetype?		(added)
	beq	40$		; yes - ignore that
	mov	r1,r2		; yes, position at byte six
	add	#6,r2		; of the output string
				; count is now three, for the file type
30$:	movb	(r0)+,(r2)+	; copy one more
	decb	r3		; until all done
	bgt	20$		;
				;
40$:	call	@dr.opn(r5)	; the driver opens the file
				;
				; r1 -> .rad50 /filnamtyp/
	mov	dr.sbl(r5),io.blk(r5) ; file start block
	clr	f$ibct		; null byte count
	fall	CloFil		; exit via CloFil return


;	CloFil - Close file service				(EMT 13)
;
;	CloFil is deprecated in the XXDP+ and XXDPV2 monitors.

PadTer:				; PadTer is deprecated
CloFil:	return			; much ado about nothing


.sbttl	Driver Get Device and Monitor Restore	    (static)	(driver)
		
;	The driver area starts here.
;
;	The four driver routines are:
;
;	DR$DEV	Get device information
;	DR$RST	Monitor restore read
;	DR$OPN	Open a file
;	DR$TRA	Transfer data
;
;	XXDP driver routines are independent of the monitor. All their
;	necessary data is contained in the driver control block. This
;	allows applications to apply the driver routines to any driver
;	and unit that they've loaded.
;
;	The XXRT interface requires two additional variables, f$inxt
;	and f$ilst, to manage I/O. The driver control block does not
;	have available space for these two variables. Because of this
;	the XXRT driver routines can only be used with the system device.
;
;	However, it turns out that all XXDP utilities (PATCH, SETUP,
;	UPD2 and XTECO) do not use the monitor driver routines to access 
;	data devices. Instead they load the XXDP drivers as needed.
;	DRS does use the monitor driver, but only ever for the system
;	device.
;
;	DR$OPN and DR$TRA have private impure data.


;	DR$DEV - Get device name/unit/media function
;
;	in	r5 ->	IOB
;
;		call	dr.dev(r5)
;
;	out	r0 ->	d$pdev: drTdev structure
;
;	Translate the dr.uni ordinal to dv.uni ascii.

	assume	dv.uni-dv.nam eq 2
dr$dev:	movr	#d$pdev+dv.uni,r0; -> dv.uni
	movb	dr.uni(r5),(r0)	;
	add	#'0,(r0)	; make it ascii
	tst	-(r0)		; r0 -> d$pdev/dv.nam
	return			;


;	DR$RST - Restore monitor function
;
;	XXDP needs a special function to read the monitor disk image 
;	because it is a contiguous file.
;
;	in	io.wct	= word count
;		io.buf	= store address
;		io.blk	= monitor relative block
;			  d$pmon is the monitor base block
;
;		call	dr.rst(r5)
;
;	out	io.buf = restored area
;
;	o Under XXDP, DR$RST reads the MFD to get d$pmon monitor
;	  block. That's not necessary for the RT-11 file system.

dr$rst:	add	d$pmon,io.blk(r5); relocate monitor block
	callr	@dr.tra(r5)	; transfer


;	DR$ERR - Common routine for driver I/O errors
;
;	in	r0 ->	unrelocated message address

dr$err:	mov	#m$siox,r0	; "?I/O error"
dr$msg:	decb	dr.sts(r5)	; dr.sts = -1 - I/O error
	JmpAbt			; abort


;	Driver error messages

m$sfnf:	.asciz	"?File not found: "
m$siox:	.asciz	"?I/O error"
	.even


.sbttl	RT-11 Open File function		    (static)	(driver)

;	R$TSEG - RT-11 directory segment header

r$tseg:
r$ttot:	.word	0	; rt.tot - total blocks (unused)
r$tnxt:	.word	0	; rt.nxt - next directory segment
	.word	0	; rt.hgh - highest segment in use (unused)	
r$text:	.word	0	; rt.ext - extra bytes per entry
r$tblk:	.word	0	; rt.blk - start block of first file in segment

;	R$TENT - RT-11 directory entry

r$tent:			;
r$tsta:	.word	0	; rt.sta - status (RTPER$ rtEND$)
	 rtPER$=2000	;	   permanent file flag
	 rtEND$=4000	; 	   end of directory segment flag
r$tfnm:	.word	0,0,0	; rt.fnm - .rad50 /filnamtyp/
r$tlen:	.word	0	; rt.len - file block length
	.word	0	; rt.tim - time (unused)
	.word	0	; rt.dat - date (unused)
       ;.blkb	rt.ext	;	 - extra bytes (from r$text above)


;	DR$OPN - RT-11 Open File function			(added)
;
;	Lookup a file in the system device RT-11 directory.
;
;	in	io.spc	.asciz "filnam.typ"
;	
;		call	dr.opn(r5)
;	
;	out	r0	burnt
;		r1 ->	.rad50 "filnam.typ" (propagates back to OpnFil)
;		dr.fnm 	.rad50 "filnamtyp"
;		dr.sbl	.word	n	; start block
;		f$inxt:	.word	n	; start block of file
;		f$ilst:	.word	n	; last block of file
;
;	fail	abort	"?File not found: filnam.typ"
;		r0 =	0
;
;	o RT-11 directory segments occupy two blocks. We have only
;	  a one-block buffer available. Thus read the directory as a
;	  sequential file a word at a time.

dr$opn:
rt$opn:	clrb	dr.sts(r5)	; reset errors
	mov	#1,r$tnxt	; first segment
	mov	sp,f$ilst	; imaginary end block (for ReaBlk logic)

;	Next segment

10$:	movr	#r$tnxt,r4	; r4 -> segment header r$tnxt
	mov	(r4),r0		; next segment index
	beq	60$		; we are done
				; translate segment index to block number 
	asl	r0		; *2  (block = (index*2)+4)
	cmp	(r0)+,(r0)+	; +4
	mov	r0,io.blk(r5)	; directory segment block number
				;
	clr	f$ibct		; force ReaBlk in ReaByt
	mov	r4,r1		; r4 -> r$tnxt
	tst	-(r1)		; r1 -> r$tseg
	mov	#5,r2		; r2 =  5-word header
	call	rt$rea		; read the header (advances r1 to r$tent)
	mov	r1,r4		; r1 -> r$tent
	tst	(r4)+		; r4 -> r$tfnm

;	Next entry

	br	30$		; no length before we find an entry
20$:	add	r$tlen,r$tblk	; start block of next file
30$:	ReaWrd			; read first word to check end-of-segment
	mov	r0,r3		; r0/r3 = r$tsta
	bit	#rtend$,r3	; end of segment?
	bne	10$		; yes
				; bona fide directory entry
	mov	r4,r1		; r1 -> r$tfnm
	mov	#6,r2		; 6 = remainder of 7-word entry
	call	rt$rea		; read the block
				;
	mov	r$text,r1	; get the extra byte count
40$:	beq	50$		; are none or all done
	ReaByt			; flush out extra bytes
	dec	r1		; count
	br	40$		;

;	Compare filenames

50$:	bit	#rtper$,r3	; rt.sta - permanent entry?
	beq	20$		; no - look at next entry
				; permanent entry
	mov	r4,r1		; r1 -> .rad50 /filnamtyp/
	movr	#d$pspc,r2	; r2 -> .ascii /filnam.typ/
	SpcAsc			; unradify
	movr	#i$ospc,r0	; r0 -> requested file spec
	CmpSpc			; r2 -> entry file spec
	 br	20$		; missmatch - next entry

;	Entry found

	mov	r4,r1		; r1 -> .rad50
	mov	r5,r2		; copy filnamtyp and first block 
	add	#dr.fnm,r2	; r2 -> d$rfnm
	mov	(r4)+,(r2)+	; dr.fil
	mov	(r4)+,(r2)+	; dr.nam
	mov	(r4)+,(r2)+	; dr.typ
	mov	r$tblk,(r2)	; dr.blk
	mov	(r2),f$ilst	; last block = start block
	add	r$tlen,f$ilst	; 	     + block length
	return			; done - r1 -> .rad50 /filnamtyp/

;	File not found message and abort

60$:	incb	dr.sts(r5)	; dr.sts = 1 - file not found error
	movr	#m$sfnf,r0	; "?File not found: "
	jmp	lf$abt		; "?File not found: filnam.typ"


;	RT$REA - Read RT-11 record
;
;	in	r1 ->	output area
;		r2 =	word count
;
;	out	r1 ->	past the output area
;		r2 =	0

rt$rea:	ReaWrd			; read another word
	mov	r0,(r1)+	; store it
	dec	r2		; got more? 
	bne	rt$rea		; this is our life
	return


.sbttl	Driver Transfer function		    (static)	(driver)
dldef$
x$xdrv:

;	Separate driver code exists for each XXDP-supported system device
;
;	dp.ufd	= 0	;3	; UFD directory start block (from init)
;	dp.spc	= 2	;"FN.T"	; space filled "filnam.typ"
;	dpspc.	= 10.	;	; 10-char name (6+1+3)
;	dp.ter	= 12	;.word 0; 1-word zero terminator
;	dpbbs.	= 14		; block length

d$pufd:	.word	6	;	; first UFD/directory block (savm)(boot)
d$pspc:	.blkb	12.	;	; .asciz "filnam.typ"<0>
d$pmon:	.word	0	;	; first monitor block	    (savm)(boot)
				; following entries filled in by rt$drv:
d$pdev:	.ascii	"DL"	;0	;\dv.nam - driver device name ("DL")
d$puni:	.ascii	""<0>	;2	;|dv.uni - driver device unit ("0")(init)
d$pmed:	.byte	mdDL.	;3 14	;/dv.med - driver device media code

;	XXRT copies the appropriate driver from the driver collection
;	to this area (when it's not the DL: driver).

d$rlow:				; drivers load here 

;	DL$TRA - DL: driver transfer function 
;
;	in	r5 ->	IOB
;			io.blk
;			io.buf
;			io.wct
;			dr.uni
;	
;		call	@dr.tra(r5)
;	
;	fine	r0/r1	unchanged
;		r2..r4	burnt
;	
;	fail	abort	"?I/O error"
;
;	O While the boot and the driver both support partial block reads,
;	  all monitor system device reads are for full blocks (see MO$CHN).

dl$tra:	psh	r0		; we do our own thing 
	psh	r1		;
	mov	(r5),r0		; r0 -> csr
	clrb	dr.sts(r5)	; assume happiness
	call	dl$res		; reset dl:

	clr	-(sp)		; (sp) = result track
	mov	io.blk(r5),r3	; r3 = requested block
	mov	#40.,r2		; r2 = sectors-per-track
10$:	sub	r2,r3		; more tracks?
	bcs	20$		; oops - too far
	inc	(sp)		; another track
	br	10$		; loop
20$:	add	r2,r3		; backup from too far
	clr	r4		; r4 = 
	asr	r2		; blocks-per-track now
30$:	sub	r2,r3		;
	bcs	40$		;
	inc	r4		;
	br	30$		;
40$:	add	r2,r3		;
	asl	r3		;
	mov	#7,r1		; compute cylinder
50$:	asl	(sp)		; shift left 
	dec	r1		;
	bne	50$		;
				;
	pop	d$lcyl		; cylinder
	psh	io.wct(r5)	;

;	Block loop
;
;	(sp)	running word count
;	d$ltwc	transaction word count

60$:	sub	#256.,(sp)	; got more than a block?
	blos	70$		; no
	mov	#256.,d$ltwc	; yes - transaction wct
	br	80$		;
70$:	mov	(sp),d$ltwc	; no - restore 
	add	#256.,d$ltwc	;
80$:	mov	r0,r1		; r1 -> csr
	add	#6,r1		; r1 -> wct
	psh	dr.uni(r5)	; 
	swab	(sp)		; (sp) = unit
	bis	#dlRHD.,(sp)	; read header
	pop	(r0)		; issue function
	call	dl$wai		; let device settle
	bmi	150$		; device error
				;
	psh	(r1)		; (sp) = wct = 
	mov	#1,-(r1)	; adr: see$
	tst	r4		;
	beq	90$		;
	bis	#20,(r1)	; adr: hea$
90$:	bic	#177,(sp)	;
	sub	d$lcyl,(sp)	;
	bcc	100$		;
	neg	(sp)		;
	bic	#177,(sp)	;
	bis	#4,(r1)		; adr: dir$
100$:	bis	(sp)+,(r1)	;
	bic	#dlFUN$,(r0)	; clear function bit field
	bis	#dlSEE.,(r0)	; set function to seek
	call	dl$opr		; perform seek and wait
	bmi	150$		; device error

110$:	bit	#dlGO$,(r0)	; wait for drive ready
	beq	110$		;
	psh	d$lcyl		; cylinder
	bis	r3,(sp)		; sector
	tst	r4		; head flag
	beq	120$		;
	bis	#100,(sp)	; head
120$:	pop	(r1)+		; adr
	psh	d$ltwc		;
	neg	(sp)		;
	pop	(r1)		; wct
	mov	io.buf(r5),2(r0);
	bic	#dlFUN$,(r0)	;
	bis	#dlREA.,(r0)	; read data
	call	dl$opr		;
	bmi	150$		; device error

	tst	(sp)		; hows the word count?
	ble	140$		; we are done
	add	#2,r3		; next block
	cmp	r3,#40.		; sectors-per-track
	blt	130$		; still within track
	clr	r3		; sector/block = 0
	inc	r4		; switch head
	bic	#177776,r4	; isolate head flag
	bne	130$		; positive
	add	#128.,d$lcyl	; advance cylinder
130$:	add	#512.,io.buf(r5); advance buffer pointer
	br	60$		;

;	Transfer completed

140$:	tst	(sp)+		; dump temp
	pop	r1		; restore
	pop	r0		;
	return

;	Transfer aborted

150$:	jmp	dr$err		; "?Read error"


;	DL$OPR - Initiate operation, wait and check errors
;
;	call	dl$opr
;	bmi	fail
;	bpl	fine

dl$opr:	bic	#dlGO$,(r0)	; activates the device
dl$wai:	bit	#dlERR$!dlGO$,(r0) ; error|ready
	beq	dl$wai		; we wait a lot
	return


;	DL$RES - Device reset

dl$res:	psh	dr.uni(r5)	; .byte unit, function
	swab	(sp)		;
	bis	#dlSTA.,(sp)	; get status
	bis	#dlREP$,dl.adr(r0) ; reset, get status
	pop	(r0)		; issue disk function
	br	dl$wai		; du$wai

d$lcyl:	.word	0		; cylinder
d$ltwc:	.word	0		; transaction word count

	dlxsiz == .-d$rlow	; resident DL: driver size
	drvmax == dlxsiz	; initial max driver size


.sbttl	Monitor end				    (static)	(end)

;	Monitor end and top of kernel memory when loaded

map$	x$xtop 20000 perend perfre


;	XX$RES - Manually resurrect XXRT after a system crash
;
;	Insert jump to the XXRT restart routine at the top of 	(added)
;	memory. For a 28k system the address is 157776 (160000-2).
;
;	in	system is an unknown state
;
;	out	CLI is reloaded and CLI engine is restarted

	perfre = perfre - 6	; account for the restart space below
	. = .-6			; size of next two instructions
xx$res:	jmp	xx$rst		; restart jump			(added)
	br	xx$res		; 

;	Calculate maximum driver size permitted

	drvavl == dlxsiz+perfre	; max driver size (shown in link map)

.if ne odt$c
.sbttl	x$xodt - ODT overlay

;	mova	c$lsig+$O,r4

;	CLI & Batch ODT command					(added)
;
;	XXRT ODT command
;
;	Examines and optionally modifies locations.
;
;	ODT [address] [=value][-/@<:]	CLI commands
;	ODT [address] [=value][-/]	Batch commands
;
;	Summary:
;
;	n	 open location	    @	   open indirect
;	<enter>	 open next	    /      exit ODT
;	- or lf	 open prior         <	   open indirect
;	=n	 deposit            :	   catch breaks
;
;	o Odd adresses are silently converted to even addresses.
;	o "??????" is reported for invalid addresses.
;	o ODT syntax is restricted to ParFld terminators (-=<:/).
;
;	ODT single-line operation:
;
;	#odt 176=200/		! deposit software switch register
;
;	ODT session:
;
;	#odt
;	000000	......	100	! open location 100
;
;	000100 ......	<enter>	! increments location
;	000102 ......
;
;	000102 ......	- 	! decrements location
;	000100 ......		! alternate: ctrl-j aka lf 
;
;	000100	......	=40	! deposits 40
;	000102	......		! advances
;
;	000100	......	=40-	! deposit
;	000100	000040		! doesn't advance
;
;	000100	.....	=1=2=3..! multi-insert 
;	000106	......		! deposits 100,102,104
;
;	000100	000200	@	! open indirect
;	000200	......		!
;				!
;	000100	000200	/	! exits ODT
;				! alternate: ctrl-c
;
;			b	! creates breakpoint
;			c	! clears breakpoint
;			g	! goto address
;			p	! proceed 
;			s	! step through instruction
;			x	! exit to CLI
;
;	000202	......		! breakpoint trap entry
;	....	......		!
;	......	......	/	! return to CLI (not program)
;
;	o The default address is zero.
;
;	r0 =	value
;	r1 =	terminator
;	r2 -> 	location
;	r3 ->	bus vector (@#4, @#6)

	map	bp.flg,,0	; bpt flag
	map	bp.adr		; bpt adress
	map	bp.sav		; saved content

;	OD$ODT - Debugger
;
;	in	r1 	terminator/command

;	Setup bus vector for address traps
;x$xodt:
o$dreg::odsig.	= 005002	; ODT region signature
od$odt:	clr	r2		; default location
	mov	#4,r3		; r3 -> @#4
	psh	(r3)		; save  @#4
	mova	od$bus,(r3)+	; @#4-> 80$
	psh	(r3)		; save  @#6
	mov	#340,(r3)	; @#6 = 340
				;
	mov	c$lnxt+$O,r0	; capture command line
	mov	r0,o$dnxt	;
	tst	r1		; #odt<enter>?
	beq	30$		; yes - display and get command
	br	60$		; no - process command

10$:	sub	#4,r2		; reverse (- 4 + 2) 
20$:	tst	(r2)+		; advance     (+ 2)
				;
30$:	call	od$dis		; display location and value
				;
40$:	GetLin			; get a value and/or command
	mov	r0,o$dnxt	;
	bcs	50$		; good
	clrb	s$ybat+$O	; leave batch
	br	40$		;
50$:	call	od$par		; get value or command
	bcs	60$		; command only
	mov	r0,r2		; save the address
	bic	#1,r2		; even up
	tstb	r1		; EOL?
	beq	30$		; yes - display location
				;
60$:	cmpb	r1,#space	; space?
	beq	50$		;
	tstb	r1		; EOL?
	beq	20$		; yes - advance
	cmpb	r1,#'-		; reverse?
	beq	10$		; yes
	cmpb	r1,#lf		; reverse?
	beq	10$		; nope
				;
	cmpb	r1,#'=		; deposit?
	bne	70$		; no
	call	od$par		; get a value
	bcs	30$		; error - no value
	mov	r0,(r2)+	; store value and advance
	br	60$		; check next command
				;
70$:	cmpb	r1,#'@		; indirect?
	bne	80$		; nope
	mov	(r2),r2		; yes - go indirect
	br	50$		; get next command
80$:	cmpb	r1,#':		; display value
	bne	90$		;
	call	od$dis		;
	br	50$		;
				;
.if ne 0
90$:	cmpb	r1,#'b		; setup BPT?
	bne	40$		; no
	mov	r2,o$dbpt	;
	inc	o$dbrk		;
	cmpb	r1,#'c		; clear BPT?
	bne	40$		; no
	clr	o$dbrk		;
	mova	od$bpt,@#14	; steal the BPT vector
.endc

90$:	cmpb	r1,#'/		; exit?
	bne	40$		; no
				; r3 -> @#6
100$:	pop	(r3)		; restore @#6
	pop	-(r3)		; restore @#4
	return			; it's all over

.if ne 0
;	OD$BPT - Catch ODT BPT trap
;
;	ODT breakpoint traps come here.

	stack	r0,r1,r2,r3,r4,r5,pc,ps
od$bpt:	pshs	<r5,r4,r3,r2,r1,r0>
	mov	sp,r5		; save r5
	mova	s$ystk+$O,sp	; use the system stack
	call	cl$zap+$O	; restore monitor/emts
	clr	@c$lnxt+$O	; purge current command line
	psha	cl$eng+$O	; return to cl$eng
	mov	(r5),r2		; r2 = interrupt address
	jmp 	od$con		; odt continuation
.endc
.sbttl	ODT utilities

;	OD$PAR - Parse next item
;
;	out	c=0	value & command
;		c=1	command
;		r0 =	value
;		r1 =	command

od$par:	pshs	<r3,r2>		;
	mov	o$dnxt,r2	; r2 -> line
	clr	r0		; r0 = result octal
	movb	(r2)+,r1	; next character
	cmpb	r1,#'0		; a digit?
	blo	30$		;
	cmpb	r1,#'7		; no
	bhi	30$		;
				;
10$:	mov	r1,r3		; next digit
	sub	#'0,r3		; de-ascii
	bit	#^c7,r3		; out of octal digit range	(added)
	bne	20$		; yes - fail return
	asl	r0		; multiply accumulator by eight
	asl	r0		;
	asl	r0		;
	add	r3,r0		; and add us in
	movb	(r2)+,r1	; r1 = next character
	br	10$		;
				;
20$:	tst	(pc)+		; c=0 - command
30$:	sec			; c=1 - value
	mov	r2,o$dnxt	;
	pops	<r2,r3>		;
	return

;	OD$DIS - ODT display location and value
;
;	000100	000200
;
;	r2 ->	location

od$dis:	mov	r2,r0		; r0 = location
	call	10$		; display location
				;
	mov	(r2),r0		; r0 = value (trap returns vbit)
	bvc	10$		; no bus trap
	mov	#30$,r0		; bus trap - display "??????"
	br	20$		;
				;
10$:	mova	o$dasc,r1	; r1 -> buffer
	OctAsc			; decode
	clrb	(r1)		; terminate ascii string
	mova	o$dasc,r0	; r0 -> ascii number
20$:	TypMsg			; display value or "??????"
	PutTab			; tab
	return			;
				;
30$:	.asciz	"??????"	; Invalid address message
	.even


;	OD$BUS - ODT bus trap routine
;
;	out	v=1	Sets the callers PSW vbit 

	stack	pc,ps
od$bus:	bis	#vbit,sp.ps(sp)	; set V-bit
	rti			; return to (r2) access instruction

o$dnxt:	.word	0
o$dasc:	.blkb	8.		; ascii number string
o$dbpt:	.blkw	3		;

map$	x$xodt 22000 topend topfre
o$dend::
.endc

;	Reserve space to save RT-11 monitor image

	.blkw	svwct.		; space to save RT-11 monitor

;	XXDRV.MAC is appended here by the MACRO command
