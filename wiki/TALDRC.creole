
==TALDRC==


[[code format="text"]]
.title	talrdc - TA11/TU60/CT: cassette diagnostic loader
.asect

.sbttl	startup

;	Control is passed here from the cassette bootstrap loader.
;
;	On entry r0 -> TACS (from the bootstrap)

	.enabl	lsb
start::	nop			; magic
	br	10$		; skip vector

	.word	su$bus, 0	; memory catch vector

10$:	tst	177570		; switch register
	bne	20$		; it's non-zero
	halt			; wait for setup

;	restart address
;	setup stack
;	size memory
;
su$rst:
20$:	mov	#1500,sp	; a no-mans-land stack
	clr	r4		; to size memory
30$:	tst	(r4)		; vectors to aXX$ if past memory
	add	#20000,r4	; next slice of memory
	br	30$		;

;	r3 ->	cassette wait routine
;	r4 ->	high memory base (for copy and relocation)

su$bus:
40$:	sub	#t$lend-t$lbeg,r4 ; relocation base (later)
	mov	#su$wai,r3	; cassette wait routine

	movb	#7,(r0)		; rewind
	call	(r3)		; wait
	movb	#35,(r0)	; skip block (directory entry)
	call	(r3)		; wait

;	Read first 768. bytes of TALDRC.PAL
;	This read benignly overwrites this code
;	(because all the variables are in registers)

	clr	r5		; load address
	mov	#1400,r2	; total bytes counter
				; sector loop
50$:	clr	r1		; sector counter
	movb	#5,(r0)		; skip block
	call	(r3)		; wait
				; byte loop
60$:	movb	2(r0),(r5)+	;

	call	(r3)		; wait
	incb	r1		; count it
	bpl	60$		; more in this sector
	bisb	#20,(r0)	; initiate crc
	call	(r3)		; wait
	sub	r1,r2		; count total
	bne	50$		; next sector

;	load done

	tst	177570		; switch register
	bne	su$cop		; go copy us
	halt			; wait for user
	.dsabl	lsb

;	copy from t$lbeg to t$lend to high memory
;	
;	r0 ->	TACS
;	r1 ->	low memory
;	r2 ->	high memory pointer
;	r3 =	byte counter
;	r4 ->	high memory

su$cop:	mov	#t$lbeg,r1	; base address
	mov	r4,r2		; r2 -> high memory

	mov	#t$lend-t$lbeg,r3 ; r3 = bytes to copy
;	mov	#1064,r3	; r3 = bytes to copy
10$:	movb	(r1)+,(r2)+	; move one
	dec	r3		; count
	bne	10$		; more
	mov	r4,pc		; continue execution high

;	local wait routine

su$wai:	bit	#240,(r0)	; wait for transfer/done
	beq	su$wai
	tst	(r0)		; errors?
	bmi	10$		; yes
	return			; nope

10$:	halt			; error halt
	br	su$rst		; and retry from beginning
.sbttl	initialize loader

;	First sector ends at 200
;
;	code copied to high memory

t$lbeg:
tl$ini:	mov	pc,r3		; relocate restart address
	add	#tl$rst-.,r3	;
	mov	r3,t$lrst	;
	mov	pc,r3		; relocate wait address
	add	#tl$wai-.,r3	;
	mov	r3,t$lwai	;
	mov	pc,r3		; relocate stack address
	add	#t$lstk-.,r3	;
	mov	r3,t$lspt	;
	mov	pc,r3		; relocate buffer address
	add	#t$lbuf-.,r3	;
	mov	r3,t$lptr	;
				;
	mov	r0,t$ltcs	; TACS
	mov	(r0),t$luni	; TACS unit

;	restart address??
;	data address
;
;	r3 ->	wait routine
;	r0 ->	TACS

tl$rst:	mov	(pc)+,sp	; stack
t$lspt:	.word	0		;
	mov	(pc)+,r3	; wait routine
t$lwai:	.word	0		;
	mov	(pc)+,r0	; TACS address
t$ltcs:	.word	0		;
	mov	(pc)+,(r0)	; TACS unit
t$luni:	.word	0		;

;	halt and pickup file number

t$lhlt:	.word	halt		; get file number
	mov	@#177570,r4	; file number
	dec	r4		; must be gt 1
	bgt	tl$pos		; fine - position at file
	halt			; try again
	br	tl$rst		; restart

tl$pos:	movb	#37,(r0)	; rewind
	call	(r3)		; wait
10$:	movb	#33,(r0)	; space forward file
	call	(r3)		; wait
	call	tl$dir		; read directory entry
	tst	@t$lptr		; is this the sentinel file?
	bne	20$		; nope
	halt			; end of tape
	br	tl$rst		; try again
20$:	dec	r4		; this our file?
	bne	10$		; more to go
;	fall	tl$ldr		; actual loader
.sbttl	absolute loader

;	found program
;	absolute loader

tl$ldr:	clr	t$lblk		; zap block start indicator
	call	tl$sec		; read initial sector
tl$seg:	clr	(pc)+		; initialze checksum
t$lchk:	.word	0		;	

	call	tl$byt		; get byte (in r2)
	dec	r2		; this the signature?
	bne	tl$seg		; nope - ignore it
	call	tl$byt		; get high byte
	tstb	r2		; MBZ
	bne	tl$seg		;

	call	tl$wrd		; get the load/transfer address
	mov	r5,r4		; segment byte count (tl$wrd)
	sub	#4,r4		; prepare for length test
	cmp	#2,r4		; is the transfer segment?
	beq	tl$tra		; yep - get remainder

	call	tl$wrd		; r5 -> load address
tl$loo:	call	tl$byt		; actual data
	bpl	tl$sto		; not checksum, store it

	tstb	t$lchk		; how's our checksum
	beq	tl$seg		; fine - do another segment
tl$chk:	halt			; oops
	movb	#7,(r0)		; space reverse file
	call	(r3)		; wait
	call	tl$dir		; get directory entry
	br	tl$ldr		; and retry load

tl$sto:	cmp	r5,t$lrst	; would this overwrite us?
	bcs	10$		; nope
	halt			; yep - we don't take that
	br	tl$rst		; restart
10$:	movb	r2,(r5)+	; actually do something
	br	tl$loo		; loop

tl$tra:	call	tl$wrd		; get the transfer address
	call	tl$byt		; get checksum byte
	tstb	t$lchk		; and the winner is...
	bne	tl$chk		; not us
				;
	movb	#5,@#41		; secrets of the temple
	ror	r5		; start address
	bcs	tl$rst		; is odd, give up
	asl	r5		; 
	mov	r5,pc		; start program
.sbttl	i/o routines	

;	get byte
;
;	r4 =	byte count
;
;	r2 =	byte
;	n=1	checksum byte

tl$fil:	call	tl$sec		; fill sector buffer
tl$byt:	dec	(pc)+		; count bytes-in-sector
t$lsbc:	.word	0		; sector byte count
	bmi	tl$fil		; fill sector buffer
	movb	(r1)+,r2	; get next
	add	r2,t$lchk	; accumulate checksum
	dec	r4		; count bytes
	return			;

;	get word
;
;	r4 =	byte count
;
;	r2 =	word

tl$wrd:	call	tl$byt		; get a byte
	mov	r2,-(sp)	; save it
	call	tl$byt		; get another
	movb	r2,1(sp)	; put it in high byte
	mov	(sp)+,r5	; r5 = word
	return

;	read 32. byte directory entry

tl$dir:	mov	#32.,t$lsbc	;  set sector byte count
	br	tl$rea		; join common

;	read 128. byte sector

tl$sec:	inc	t$lblk		; track block status
	bic	#177774,t$lblk	; reduce to 2 bits
	mov	#128., t$lsbc	; sector counter

;	read common
;
;	544:	byte count
;
;	r1 ->	buffer

tl$rea:	mov	(pc)+,r1	; r1 -> buffer
t$lptr:	.word	0		;
	movb	#5,(r0)		; read
	call	(r3)		; wait
10$:	movb	2(r0),(r1)+	; store byte
	call	(r3)		; wait
	dec	t$lsbc		; sector byte count
	bne	10$		;
	bisb	#20,(r0)	; set end-of-sector
	call	(r3)		; do end-of-sector processing

;	Return pointer and counter
;
;	r1 ->	buffer
;	544 =	byte count

	mov	t$lptr,r1	; r1 -> buffer
	mov	#128.,t$lsbc	; reset sector byte count

; 	Fudge XXDP disk structure
;
;	If first sector of data block
;
;	1. Pop past the first word (the XXDP next-block pointer)
;	2. Decrease the byte count

	cmp	#1,t$lblk	; new block?
	bne	20$		; nope
	tst	(r1)+		; skip first word of block
	sub	#2,t$lsbc	; adjust sector byte count
20$:	return

;	wait routine
;	264: -> here
;
tl$wai:	tstb	(r0)		; done?
	bmi	10$		; yep
	bit	#40,(r0)	; transfer done?
	beq	tl$wai		; nope
	tst	(r0)		; some error?
	bmi	20$		; yep
10$:	return			;
20$:	halt			;
	mov	(pc),pc		; restart
t$lrst:	.word	0		; restart address

t$lblk:	.word	0		; block flag (1 => first sector of block)

;	128-byte buffer
;	random data

t$lbuf:	. = . + 128.		; buffer
	. = . + 12.		; 7-word stack
t$lstk:
.sbttl	bootstrap loader

;	top-of-memory bootstrap loader
;
;	This code performs no function for TALDRC.
;	It is placed at memory-top as a courtesy to the user.

bl$sta:	mov	#177500,r0	; r0 -> TACS
	clr	(r0)		; unit 0
10$:	mov	pc,r1		; relocate
	add	#b$ltab-.,r1	; r1 -> operation table
	mov	#375,r2		; magic counter
	movb	(r1)+,r3	; test mask

20$:	movb	(r1)+,(r0)	; next operation
	bmi	50$		; that was all
30$:	bitb	r3,(r0)		; wait for it
	beq	30$		;
	incb	r2		; count it
	bmi	20$		; still doing startup
	movb	2(r0),(r2)	; get next byte
	cmpb	r3,@#0		; is this sensible?
	beq	30$		; yes			
40$:	halt			;
	br	10$		; start over

50$:	tst	(r0)		; any errors
	bmi	40$		; yes - halt
	clr	pc		; start it

b$ltab:	.byte	240		; ready + transfer-request mask
	.byte	37		; lbs, rewind, go
	.byte	15		; space-forward-block, go
	.byte	5		; read
	.byte	24		; lbs, read (no go) 
	.byte	224		; lbs, read and table done (200)
	.word	0		; unused word

t$lend:

	.end	start

[[code]]

